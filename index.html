<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="ghost">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="ghost">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ghost">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>ghost</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ghost</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/02/数据库优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/数据库优化/" itemprop="url">数据库优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-02T14:39:35+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h3><p> 要解决数据量大的问题，是避不开数据库优化的，数据库优化可以在不增加硬件的情况下提高处理效率，这是一种用技术换金钱的方式，数据库优化的方法非常多，常用的由表结构化，SQL语句优化，分区和分表，索引优化，适应存储过程代替直接操作等，另外有时候合理使用冗余也能获得非常好的效果。  </p>
<ul>
<li>表结构优化<br>表结果优化是数据库中最基础也是最重要的，如果表结构优化得不合理，就可能导致严重的性能问题，具体怎么设计更合理也没有固定不变的准则，需要根据实际情况具体处理。  </li>
<li>SQL语句优化<br>SQL语句优化也是非常重要的，基础的SQL优化是语法层面的优化，不过更重要的是处理逻辑的优化，这也需要根据实际情况具体处理，而且要和索引缓存等配合使用。不过SQL优化有一个通用的做法就是，首先要将涉及大数据的业务的SQL语句执行时间详细记录下来，其次通过仔细分析日志（同一条语句对不同条件的执行时间也可能不同，这点也需要仔细分析）找出需要优化的语句和其中的问题，然后再有的放矢地优化，而不是不分重点对每条语句都花同样的时间和精力优化。 </li>
<li>分区<br>当数据量变多的时候，如果可以分区或者分表，那将起到非常好的效果，当一张表中的数据量变多的时候操作速度就变慢了，所以很容易想到的就是将数据分到多个表中保存，但是这么做之后操作起来就麻烦了，像操作（增删查改）一个数据还需要先找到对应的表，如果涉及多个表还得跨表操作。其实在常用的数据库中可以不分表二达到跟分表类似的效果，那就是分区，分区就是将一张表中的数据按照一定的规则分到不同的区来保存，这样在查询数据时如果数据在同一个区内那么可以只对一个区的数据进行操作，这样操作的数据量更少，速度更快，而且这种方法对程序是透明的，程序不需要做任何改动。  </li>
<li>分表<br>如果一个表中的数据可以分为几种固定不变的类型，而且如果同时对多种类型共同操作的情况不多，那么都可以通过份表来处理，这也需要具体情况具体对待。笔者之前对一个业务系统进行重构开发时就将其中保存工人工作卡片的数据表分成了三个表，并且对每个表进行分区，在同时使用缓存（主要用于在保存和修改时对其他表的数据获取中，如根据工人Id获取工人姓名，工人类别，所在单位，所在工段及班组等信息），索引，SQL优化等的情况下操作速度比原来提高了100倍以上，那时的分表是按照工作卡片的类型来划分的，因为当时的要求是要保留所有的记录，比如，修改了卡片的信息，则需要保存是谁在什么时候对卡片进行修改，修改前的数据是什么，添加删除也一样，这种需求一般的做法就是用一个字段来做卡片状态的标志位，将卡片分为不同的类型。不过这里由于数据量非常大所以就把卡片分别保存到了三个表中，第一个表保存正常卡片，第二个表保存删除后的卡片，第三个表保存修改之前的卡片，并且对每个表都进行了分区，由于报表都是按月份，季度，半年和年来做的，所以分区是按月份来分的，每个月一个分区，这样问题就解决了。<br>另外一种分表的方法是将一个表中不同类型的字段分到不同的表中保存，这么做最直接的好处就是增删查改数据的时候锁定的范围变小了，没被锁定的表中的数据不受影响，如果一个表的操作频率很高，在增删改其中一部分字段数据的同时另一部分字段也可能被操作，而且（主要指查询）用不到被增删改的字段，那么就可以把不同类型的字段分贝保存到不同的表中，这样就减少操作时锁定数据的范围了，不过这样分表之后，如果需要查询完整的数据就得使用多表操作了.  </li>
<li>索引优化<br>索引的大致原理就是数据发生变化（增删改）的时候就预先制定字段的顺序排列后保存到一个类似表的结构中，这样在查找索引字段为条件的记录时就可以很快的从索引中找到对饮记录的指针并从表中获取到记录，这样速度就快多了。不过索引也是一把双刃剑，它在提高查询速度的同时也降低了增删改的速度，因为每次数据的变化都需要更新相应的索引，不过合理使用索引对提高查询速度的效果非常明显，所以对哪些字段使用索引，使用什么类型的索引都需要仔细琢磨，并且最好再做一些测试。  </li>
<li>使用存储过程代替直接操作<br>在操作过程复杂而且调用频率高的业务中，可以通过使用存储过程代替直接操作来提高效率，因为存储过程只需要编译一次，而且可以在一个存储过程里面做一些复杂的操作。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/02/redis第一篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/redis第一篇/" itemprop="url">redis第一篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-02T10:05:08+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/25/elasticsearch第二篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/25/elasticsearch第二篇/" itemprop="url">elasticsearch第二篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-25T11:10:25+08:00">
                2018-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h4><p><code>类似数据库中的表结构定义</code></p>
<ul>
<li><p>作用</p>
<ul>
<li>定义Index下的字段名(Field Name)  </li>
<li>定义字段的类型,比如数值型,字符串型,布尔型等  </li>
<li>定义倒排索引相关的配置,比如是否索引,记录  position等<br>得到一个索引的mapping  <code>GET /test_index/_mapping</code>  </li>
</ul>
</li>
<li><p>自定义Mapping  </p>
<ul>
<li>禁止直接修改<br> Mapping中的字段类型一旦设定后,禁止直接修改,因为Lucene实现的倒排索引生成后不允许修改,可以重新建立新的索引,然后做reindex操作</li>
<li>允许新增字段 <code>通过dynamic参数来控制字段的新增</code>  <ul>
<li>true(默认)允许自动新增字段  </li>
<li>false不允许自动新增字段,但是文档 可以正常写入,但无法对字段进行查询等操作  </li>
<li>strict文档不能写入,报错<br>-几个设置</li>
<li>copy_to<br><code>将该字段的值复制到目标字段,实现类似_all的作用,不会出现在_source中,只用来搜索</code></li>
<li>index<br><code>控制当前字段是否索引,默认为true,即记录索引,false不记录,即不可搜索</code>  </li>
<li>index_options用于控制倒排索引记录的内容,有如下4种配置:<ul>
<li>docs只记录doc id  </li>
<li>freqs记录doc id和term frequencies(词频)</li>
<li>positions记录doc id,term frequencies和term position</li>
<li>offsets记录doc id,term frequencies,term position和character offsets<br>text类型默认配置为positions,其他默认为docs<br>记录内容越多,占用空间越大</li>
</ul>
</li>
<li>null_value<br><code>当字段遇到null值时的处理策略,默认为null,即空值,此时es会忽略该值,可以通过设定该值设定字段的默认值</code></li>
</ul>
</li>
</ul>
</li>
<li>Dynamic Mapping<br><code>es是依靠JSON文档的字段来实现自动识别字段类型</code>  </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/25/elasticsearch第一篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/25/elasticsearch第一篇/" itemprop="url">elasticsearch第一篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-25T11:07:22+08:00">
                2018-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h4><p><strong>文档 Document</strong><br><code>用户存储在es中的数据类型</code></p>
<ul>
<li><p>数据类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">核心数据类型</span><br><span class="line">    1.字符型:text,keyword</span><br><span class="line">    2.数值型:long,integer,short,byte,float,half_float,scaled_float</span><br><span class="line">    3.布尔:boolean</span><br><span class="line">    4.日期:date</span><br><span class="line">    5.二进制:binary</span><br><span class="line">    6.范围类型:integer_range,float_range,long_range,double_range,date_range,date_range</span><br><span class="line">复杂数据类型</span><br><span class="line">    1.数组类型array</span><br><span class="line">    2.对象类型object</span><br><span class="line">    3.嵌套类型nested object</span><br><span class="line">地理位置数据类型 </span><br><span class="line">    1.geo_point</span><br><span class="line">    2.geo_shape</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注:每个文档有唯一的id标识  </span><br><span class="line">1).自行指定  </span><br><span class="line">2).es自动生成</span><br></pre></td></tr></table></figure>
</li>
<li><p>元数据<br><code>用于标注文档的相关信息</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1._index:文档所在的索引名  </span><br><span class="line">2._type:文档所在的类型名</span><br><span class="line">3._id:文档唯一id</span><br><span class="line">4._source:文档的原始Json数据,可以从这里获取每个字段的内容</span><br><span class="line">5._all:整合所有字段内容到该字段,默认禁止</span><br></pre></td></tr></table></figure>
</li>
<li><p>文档Document API</p>
<ul>
<li><p>创建文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1.指定id创建文档api如下:</span><br><span class="line">PUT /test_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;username&quot;:&quot;hh&quot;,</span><br><span class="line">    &quot;age&quot;:1</span><br><span class="line">&#125;</span><br><span class="line">2.不指定id创建文档api如下:</span><br><span class="line">POST /test_index/doc</span><br><span class="line">&#123;</span><br><span class="line">    &quot;username&quot;:&quot;hh&quot;,</span><br><span class="line">    &quot;age&quot;:1</span><br><span class="line">&#125;</span><br><span class="line">3.es允许一次创建多个文档,从而减少网络传输开销,提升写入速率</span><br><span class="line">POST _bulk</span><br><span class="line">&#123;</span><br><span class="line">    &quot;index&quot;:&#123;</span><br><span class="line">        &quot;_index&quot;:&quot;test_index&quot;,&quot;_type&quot;:&quot;doc&quot;,&quot;id&quot;:&quot;3&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;username&quot;:&quot;hh&quot;,&quot;age&quot;:10</span><br><span class="line">    &#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;delete&quot;:&#123;</span><br><span class="line">        &quot;_index&quot;:&quot;test_index&quot;,&quot;_type&quot;:&quot;doc&quot;,&quot;_id&quot;:&quot;3&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;update&quot;:&#123;</span><br><span class="line">        &quot;_id&quot;:&quot;3&quot;,&quot;_index&quot;:&quot;test_index&quot;,&quot;_type&quot;:&quot;doc&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;doc&quot;:&#123;</span><br><span class="line">        &quot;age&quot;:&quot;20&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1.指定要查询的文档id</span><br><span class="line">GET/test_index/doc/1</span><br><span class="line">2.搜索所有文档,用到_search,如下:</span><br><span class="line">GET /test_index/doc/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;term&quot;:&#123;</span><br><span class="line">            &quot;_id&quot;:&quot;1&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">2.es允许一次查询多个文档</span><br><span class="line">GET /_mget</span><br><span class="line">&#123;</span><br><span class="line">    &quot;docs&quot;:&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;_index&quot;:&quot;test_index&quot;,</span><br><span class="line">            &quot;type&quot;:&quot;doc&quot;,</span><br><span class="line">            &quot;_id&quot;:&quot;1&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;_index&quot;:&quot;test_index&quot;,</span><br><span class="line">            &quot;_type&quot;:&quot;doc&quot;,</span><br><span class="line">            &quot;_id&quot;:&quot;2&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新文档</p>
</li>
<li>删除文档</li>
</ul>
</li>
</ul>
<p><strong>索引 Index</strong><br><code>由具有相同字段的文档列表组成</code></p>
<ul>
<li>索引中存储具有相同结构的文档(Document)   <ul>
<li>每个索引都有自己的mapping定义,用于定义字段名和类型  </li>
</ul>
</li>
<li>一个集群可以有多个索引  <ul>
<li>nginx日志存储的时候可以按照日期每天生成一个索引来存储</li>
</ul>
</li>
<li>索引API<br><code>es有专门的Index API,用于创建,更新,删除索引配置等</code>  <ul>
<li>创建索引api  <code>PUT/test/index</code>  </li>
<li>查看现有索引  <code>GET _cat/indices</code>  </li>
<li>删除索引api  <code>DELETE/test_index</code>  </li>
</ul>
</li>
<li>倒排索引与分词<ul>
<li>正排索引<code>文档Id到文档内容,单词的关联关系</code></li>
<li>倒排索引<code>单词到文档Id的关联关系</code><ul>
<li>单词词典<code>是倒排索引的重要组成</code><ul>
<li>记录所有文档的单词,一般比较大</li>
<li>记录单词到倒排列表的关联信息</li>
</ul>
</li>
<li>倒排列表<code>记录了单词对应的文档集合,由倒排索引项组成</code><br>倒排索引项(Posting)主要包含以下信息:<ul>
<li>文档Id,用于获取原始信息</li>
<li>单词频率(TF,Term Frequency),记录该单词在该文档中的出现次数,用于后续相关性算分</li>
<li>位置(Position),记录单词在文档中的分词位置(多个),用于做词语搜索(Phrase Query)</li>
<li>偏移(Offset),记录单词在文档的开始和结束位置,用于做高亮显示</li>
</ul>
</li>
</ul>
</li>
<li>分词<code>是指将文本转换成一系列单词(term or token)的过程,也可以叫做文本分析,在es中里面称为Analysis</code><br><strong>节点 Node</strong><br><code>一个Elasticsearch的运行实例,是集群的构成单元</code><br><strong>集群 Cluster</strong><br><code>由一个或多个节点组成,对外提供服务</code>  <h4 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h4><code>是es中专门处理分词的组件,英文名为Analyzer</code></li>
</ul>
</li>
<li>组成部分:<ul>
<li>Character Filters  <code>针对原始文本进行处理,比如去除html特殊标记</code></li>
<li>Tokenizer  <code>将原始文本按照一定规则切分为单词</code></li>
<li>Token Filters  <code>针对tokenizer处理的单词再加工,比如转小写,删除或新增等处理</code></li>
</ul>
</li>
<li>预定义的分词器<br><code>es自带如下的分词器:</code>  <ul>
<li>Standard<ul>
<li>默认分词器</li>
<li>按词切分,支持多语言</li>
<li>小写处理</li>
</ul>
</li>
<li>Simple  <ul>
<li>按照非字母切分</li>
<li>小写处理</li>
</ul>
</li>
<li>Whitespace <ul>
<li>按照空格切分 </li>
</ul>
</li>
<li>Stop  <ul>
<li>Stop Word指语气助词等修饰性的词语,比如the,an,的,这等等</li>
<li>相比Simple多了Stop Word处理</li>
</ul>
</li>
<li>Keyword <ul>
<li>不分词,直接将输入作为一个单词输出 </li>
</ul>
</li>
<li>Pattern  <ul>
<li>通过正则表达式自定义分隔符</li>
<li>默认是\W+,即非字符的符号作为分隔符 </li>
</ul>
</li>
<li>Language  <ul>
<li>提供了30+常见语言的分词器  </li>
</ul>
</li>
</ul>
</li>
<li>中文分词<ul>
<li>中文分词指的是将一个汉字序列切分为一个一个单独的词,在英文中,单词之间是以空格作为自然分界符,汉语中词没有一个形式上的分界符</li>
<li>上下文不同,分词结果迥异,比如交叉歧义问题,比如下面两种分词都合理<ul>
<li>乒乓球拍/卖/完了</li>
<li>乒乓球/拍卖/完了</li>
</ul>
</li>
<li>常见分词系统<ul>
<li>IK<ul>
<li>实现中英文单词的切分,支持ik_smart,ik_maxword等模式</li>
<li>可自定义词库,支持热更新分词词典</li>
<li><a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik</a></li>
</ul>
</li>
<li>jieba  <ul>
<li>python中最流行的分词系统,支持分词和词性标注  </li>
<li>支持繁体分词,自定义词典,并行分词等  </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>自定义分词<br><code>当自带的分词无法满足需求时,可以自定义分词,通过自定义Character Filters,Tokenizer和Token Filter实现</code>  <ul>
<li>Character Filters <ul>
<li>自带的如下:  <ul>
<li>HTML Strip去除html标签和转换html实体</li>
<li>Mapping进行字符替换操作</li>
<li>Pattern Replace进行正则匹配替换</li>
</ul>
</li>
<li>会影响后续tokenizer解析的postion和offset信息</li>
</ul>
</li>
<li>Tokenizer<ul>
<li>自带的如下:<ul>
<li>standard按照单词进行分割</li>
<li>letter按照空格进行分割</li>
<li>whitespace按照空格进行分割  </li>
<li>UAX URL Email按照standard分割,但不会分割邮箱和url</li>
<li>NGram和Edge NGram连词分割</li>
<li>Path Hierarchy按照路径进行分割<h4 id="Analyze-API"><a href="#Analyze-API" class="headerlink" title="Analyze API"></a>Analyze API</h4><code>es提供了一个测试分析的api接口,方便验证分词效果,endpoint是_analyze</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>可以直接指定analyzer进行测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">    &quot;analyzer&quot;:&quot;standard&quot;,</span><br><span class="line">    &quot;text&quot;:&quot;hello world!&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以直接指定索引中的字段进行测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST test_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">    &quot;field&quot;:&quot;username&quot;,</span><br><span class="line">    &quot;text&quot;:&quot;hello world&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以自定义分词器进行测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">    &quot;tokenizer&quot;:&quot;standard&quot;,</span><br><span class="line">    &quot;filter&quot;:[&quot;lowercase&quot;],</span><br><span class="line">    &quot;text&quot;:&quot;Hello World!&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/24/Elastic-Stack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/24/Elastic-Stack/" itemprop="url">Elastic Stack概述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-24T20:04:32+08:00">
                2018-04-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Elastic-Stack概述"><a href="#Elastic-Stack概述" class="headerlink" title="Elastic Stack概述"></a>Elastic Stack概述</h3><ul>
<li>elasticsearch是数据存储,查询与分析</li>
<li>kibana是数据探索与可视化分析</li>
<li>Beats,Logstash是数据收集与处理<h4 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h4></li>
<li><p>安装elasticsearch<br>进入<a href="https://www.elastic.co/cn/" target="_blank" rel="noopener">elasticsearch官网</a>,下载对应自己电脑型号和版本的压缩包,解压,进入bin目录,执行elasticsearch,启动elasticsearch</p>
</li>
<li><p>elasticsearch配置说明<br>1).cluster.name集群名称,以此作为是否同一集群的判断条件<br>2).node.name节点名称,以此作为集群中不同节点的区分条件<br>3).network.host/http.port网络地址和端口,用于http和transport服务使用<br>4).path.data数据存储地址<br>5).path.log日志存储地址</p>
</li>
<li><p>elasticsearch本地启动集群的方式<br>1).bin/elasticsearch<br>2).bin/elasticsearch -Ehttp.port=8200 -Epath.data=node2</p>
</li>
</ul>
<ol start="3">
<li>bin/elasticsearch -Ehttp.port=7200 -Epath.data=node3</li>
</ol>
<ul>
<li><p>如何验证三个节点组成一个集群<br>在浏览器上输入<a href="http://127.0.0.1:7200/_cat/nodes" target="_blank" rel="noopener">http://127.0.0.1:7200/_cat/nodes</a>,<br>就会展示<br>127.0.0.1 27 58 8    mdi - ZSq9WKC<br>127.0.0.1 28 58 6    mdi - V8BTpaW<br>127.0.0.1 29 58 8    mdi * Z_C-ibU<br>如果出现就证明成功</p>
</li>
<li><p>如何判断哪个是主节点,哪个是从节点<br>在浏览器上输入<a href="http://127.0.0.1:7200/_cat/nodes?v" target="_blank" rel="noopener">http://127.0.0.1:7200/_cat/nodes?v</a><br>然后出来<br>ip        heap.percent ram.percent cpu load_1m load_5m load_15m node.role master name<br>127.0.0.1   28    42  13              mdi       -      ZSq9WKC<br>127.0.0.1   28    42  13              mdi       -      V8BTpaW<br>127.0.0.1   29    42  13              mdi       <em>      Z_C-ibU<br>注:</em>代表主节点</p>
</li>
<li><p>如何查看集群的状态消息<br>在浏览器上输入<br><a href="http://127.0.0.1:7200/_cluster/stats" target="_blank" rel="noopener">http://127.0.0.1:7200/_cluster/stats</a></p>
</li>
<li>常用术语<br>1).Document文档数据<br>2).Index索引<br>3).Type索引中的数据类型<br>4).Field字段,文档的属性<br>5).Query DSL查询语法<h4 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h4></li>
<li>下载kibana<br>进入<a href="https://www.elastic.co/cn/" target="_blank" rel="noopener">kibana官网</a>下载<br>进入kibana的bin目录下,执行kibana,就启动kibana了</li>
<li>kibana.yml关键配置说明<br>1).server.host/server.port访问kibana用的地址和端口<br>2).elasticsearch.url待访问elasticsearch的地址</li>
<li>kibana常用功能说明<br>1).Discover数据搜索查看<br>2).Visualize图表制作<br>3).Dashboard仪表盘制作<br>4).Timelion时序数据的高级可视化分析<br>5).DevTools开发者工具<br>6).Management配置<h4 id="beats"><a href="#beats" class="headerlink" title="beats"></a>beats</h4></li>
<li>轻量级的数据传送<br>1).Filebeat日志文件<br>2).Metricbeat 度量数据<br>3).Packetbeat 网络数据<br>4).Winlogbeat Windows数据<br>5).Heartbeat健康检查</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/云上快速搭建WordPress网站/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/云上快速搭建WordPress网站/" itemprop="url">云上快速搭建WordPress网站</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-22T13:19:55+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="关于LAMP"><a href="#关于LAMP" class="headerlink" title="关于LAMP"></a>关于LAMP</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;LAMP是指Linux(操作系统),Apache HTTP服务器,MySQL(有时也指MariaDB)数据库软件和PHP(有时也指Peri或Python)的首字母,一百用来建立web应用平台.和Java/J2EE架构相比,LAMP具有通用,跨平台,高性能,低价格的优势,因此LAMP无论是性能,质量还是价格都是企业搭建网站的首选平台.<br>&nbsp;&nbsp;&nbsp;&nbsp;Linux是一套免费使用和自由传播的类UNIX操作系统,目前运用最广泛使用人数最多的操作系统.<br>&nbsp;&nbsp;&nbsp;&nbsp;Apache是LAMP架构最核心Web Server,开源,稳定,模块丰富是Apache的优势,但Apache的缺点是有点臃肿,内存和CPU开销大,性能上有损耗,不如一些轻量级的Web服务器(例如ngnix)高效,轻量级的Web服务器对于静态文件的响应能力来说远高于Apache服务器.Apache做为Web Server是负载PHP的最佳选择,如果流量很大的话,可以采用ngnix来负载非PHP的Web请求.<br>&nbsp;&nbsp;&nbsp;&nbsp;PHP是一种通用开源脚本语言,语法吸收了C语言,Java和Perl的特点,利于学习,使用广泛,主要适用于Web开发领域,PHP独特的语法混合了C,Java,Perl以及PHP自创的语法,它可以比CGL或者Perl更快速地执行动态网页,用PHP做出的动态页面与其他的编程语言相比,PHP是将程序嵌入到HTML(标准通用标记语言下的一个应用)文档中去执行,执行效率比完全生成HTML标记的CGL要高出许多;PHP还可以执行编译后代码,编译可以达到加密和优化代码运行,使代码运行更快.<br>&nbsp;&nbsp;&nbsp;&nbsp;开源的数据库中,MySQL在性能,稳定性和功能上是首选,可以达到百万级别的数据存储,网站初期可以将MySQL和Web服务器放一起,但是当访问量达到一定规模后,应该将MySQL数据库从Web Server上独立出来,在单独的服务器上运行,同时保持Web Server和我MySQL服务器的稳定连接.  </p>
<h3 id="关于WordPress"><a href="#关于WordPress" class="headerlink" title="关于WordPress"></a>关于WordPress</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;WordPress是一种使用PHP语言开发的博客平台,用户可以在支持PHP和MySQL数据库的服务器上架构WordPress.可以使用WordPress搭建一个简单的独立博客,也可以把WordPress当作一个内容管理系统(CMS),用来搭建一个小门户网站,现在的WordPress已经强大到几乎可以搭建目前所有常见类型的网站,比如门户,下载站,淘宝客,论坛,多博客等等.</p>
<h2 id="关于CNZZ"><a href="#关于CNZZ" class="headerlink" title="关于CNZZ"></a>关于CNZZ</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;CNZZ是一个进行网页统计的平台,可以帮助站长收集网站上用户的浏览器分布,IP分布,流量等公开信息,方便网站管理,使得站长可以了解访问量变化,是不是被搜索引擎封杀等情况,及时作出应对.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/文件上传/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/文件上传/" itemprop="url">文件上传</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-22T13:19:55+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="文件上传概述"><a href="#文件上传概述" class="headerlink" title="文件上传概述"></a>文件上传概述</h3><p>1.文件上传是什么<br>&nbsp;&nbsp;&nbsp;&nbsp;在web开发中经常需要从客户端向服务器上传文件,如:上传照片,上传新闻图片,上传附件等等,这些都需要通过web开发中的文件上传技术实现.<br>2.文件上传步骤<br>&nbsp;&nbsp;&nbsp;&nbsp;实现wb开发中的文件上传功能只需要两个步骤:<br>&nbsp;&nbsp;&nbsp;&nbsp;(1).提供一个带有文件上传项的表单.<br>&nbsp;&nbsp;&nbsp;&nbsp;(2).在servlet中读取处理上传的文件,保存到服务器.</p>
<h3 id="文件上传实现"><a href="#文件上传实现" class="headerlink" title="文件上传实现"></a>文件上传实现</h3><p>1.在用户页面中添加上传输入项(客户端页面操作)<br><code>&lt;input type=&quot;file&quot; name=&quot;filex&quot;&gt;</code><br>&nbsp;&nbsp;&nbsp;&nbsp;注意事项:<br>&nbsp;&nbsp;&nbsp;&nbsp;(1).必须为文件上传input提供name属性,否则文件上传内容不会被表单提交.<br>&nbsp;&nbsp;&nbsp;&nbsp;(2).表单的提交方式必须为post(get提交数据在url地址上显示,有长度限制)<br>&nbsp;&nbsp;&nbsp;&nbsp;(3).表单必须设置enctype=multipart/form-data<br>2.在服务器端编写文件上传程序<br>&nbsp;&nbsp;&nbsp;&nbsp;通过Request对象提供一个getInputStream方法,可以读取到客户端提交过来的数据,但这种方式还需要对流中获取到的数据进行处理.<br>&nbsp;&nbsp;&nbsp;&nbsp;为了简化这个处理过程,Apache开源组织提供了一个用来处理表单文件上传的一个开源组件(Commons-fileupload),让开发人员轻松实现web文件上传功能.<br>3.上传组件(Apache commons-fileupload)使用过程<br>&nbsp;&nbsp;&nbsp;&nbsp;首先需要下载并导入该组件相关的支撑jar包:Commons-filesupload和commons-io,然后编程实现,步骤如下:<br>    (1)创建DiskFileItemFactory对象,设置缓冲区大小和临时文件目录</p>
<pre><code>public DiskFileItemFactory(int sizeThreshold,java.io.File repository) 
//构造工厂时,指定内存缓冲区大小和临时文件存放位置
public void setSizeThreshold(int sizeThreshold)
//设置内存缓冲区大小,默认10k
public void setRepository(java.io.File repository)
//设置临时文件存放位置,默认 System.getProperty(&quot;java.io.tmpdir&quot;)
*内存缓存区:上传文件时,上传文件的内容优先保存在内存缓冲区中,当
*上传文临时大小超过缓冲区大小,就会在服务器端产生临时文件
*临时文件存放位置:保存超过了内存缓冲区大小上传文件而产生临时文件
*产生临时文件可以通过FileItem的delete方法删除
</code></pre><p>(2).使用DiskFileItemFactory对象创建ServletFileUpload对象,并设置上传文件的大小限制.<br>(3).调用ServletFileUpload.parseRequest方法解析request对象,得到一个保存了所有上传FileItem的list集合  </p>
<pre><code>ServeltFIleUpload负责处理上传的文件数据,并将表单中每个输入项封装成一个FileItem对象中.常用的方法有:
//判断上传表单是否为multipart/form-data类型
boolean isMutipartContent(HttpServletRequest request)
//解析request对象,并把表单中的每一个输入项包装成fileItem对象,并返回一个保存了所有FileItem的list集合.
List parseRequest(HttpServletRequest request)
//设置单个上传文件的最大值
setFileSizeMax(long fileSizeMax)
//设置上传文件总量的最大值
setSizeMax(long sizeMax)
//解决上传文件名乱码问题
setHeadEncoding(java.lang.String encoding)
//实时监听文件上传状态
setProgressListener(ProgressListener pListener)
</code></pre><p>(4).对List进行迭代,每迭代一个FileItem对象,调用其isFormField方法判断是否上传文件.<br>&nbsp;&nbsp;&nbsp;&nbsp;True为普通表单字段,则调用getFieldName,getString方法得到字段名和字段值.<br>&nbsp;&nbsp;&nbsp;&nbsp;False为上传文件项,则调用getInputStream方法得到数据输入流,从而读取上传数据.<br>(5).如果是文件上传就通过流获取上传的数据保存到服务器中.  </p>
<pre><code>boolean idFormField()判断FileItem是一个文件上传对象还是普通字段项:
String getFieldName() 获得普通表单对象的name属性
String getString(String encoding)获得普通表单对象的value属性,可以用encoding进行编码设置
文件上传项:
String getName()获得上传文件的文件名(有些浏览器会携带客户端路径)
InputStream getInputStream()获得上传文件的输入流
delete() 在关闭FileItem输入流后,删除临时文件
</code></pre><h3 id="上传文件的监听"><a href="#上传文件的监听" class="headerlink" title="上传文件的监听"></a>上传文件的监听</h3><pre><code>//ServletFileUpload类提供了如下方法,监听文件上传时的进度信息:
pulbic void setProgressListener(ProgressListener pListener)
//设置监听器,文件上传程序会自动执行,监听器中update方法
public void update(long pBytesRead,long pContentLength,int pItems)
//在方法中可以获得文件总大小,已经上传大小和上传第几个元素
能否根据上面三个参数计算:剩余大小、传输速度、已用时间、剩余时间
(1).已用时间 = 当前时间 -开始时间
(2).速度 = 已经上传大小/已用时间
(3).剩余时间 = 总大小 - 已经上传大小
(4).剩余时间 = 剩余大小/速度
</code></pre><h3 id="上传文件注意问题"><a href="#上传文件注意问题" class="headerlink" title="上传文件注意问题"></a>上传文件注意问题</h3><p>1.文件保存位置<br>&nbsp;&nbsp;&nbsp;&nbsp;上传的文件如果直接存放在web应用根目录下,通过浏览器是可以直接访问的,如果用户上传一个JSP,再通过浏览器访问就可以通过文件上传在服务器执行任意的java代码,十分危险.<br>&nbsp;&nbsp;&nbsp;&nbsp;所以一定要注意,文件上传服务器保存文件的位置必须是WEB-INF目录下或服务器中浏览器无法访问的位置.<br>2.防止上传的文件重名覆盖<br>&nbsp;&nbsp;&nbsp;&nbsp;上传的文件如果重名,后上传的文件就会覆盖先上传文件.&nbsp;&nbsp;&nbsp;&nbsp;为了防止这样的问题产生,应该对文件名进行处理,可以在文件名钱拼接UUID,防止文件名重复.<br><code>filename = UUID.randomUUID().toString()+&quot;_&quot;+filename;</code><br>3.防止同一个目录下上传文件过多<br>&nbsp;&nbsp;&nbsp;&nbsp;一个目录下如果文件过多,必须会导致访问效率下降,所以我们需要将上传的文件进行分目录存储.<br>&nbsp;&nbsp;&nbsp;&nbsp;分目录存储的算法可以有很多:<br>&nbsp;&nbsp;&nbsp;&nbsp;(1).按照上传时间进行目录分离(周,月)<br>&nbsp;&nbsp;&nbsp;&nbsp;(2).按照上传用户进行目录分离—为每个用户建立单独目录<br>&nbsp;&nbsp;&nbsp;&nbsp;(3).按照固定数量进行目录分离–假设每个目录只能存在3000个文件后,创建一个新的目录<br>&nbsp;&nbsp;&nbsp;&nbsp;(4).按照唯一文件名的hashcode进行目录分离</p>
<pre><code>public static String generateRandomDir(String uui获dFileName){
//获得唯一文件名的hashcode
int hashcode = uuidFileName.hashCode();
//获得一级目录
int d1 = hashcode &amp; 0xf;
//获得二级目录
int d2 = (hashcode &gt;&gt;&gt; 4)&amp;0xf;
return &quot;/&quot;+ d2 + &quot;/&quot;+ d1;//共有256目录
}
</code></pre><p>4.文件上传代码</p>
<pre><code>1.创建一个UploadServlet类
try {
    response.setCharacterEncoding(&quot;utf-8&quot;);
    response.setContentType(&quot;text/html;charset=utf-8&quot;);

    //1.创建文件上传工厂
    DiskFileItemFactory factory = new DiskFileItemFactory(100, new File(this.getServletContext().getRealPath(&quot;WEB-INF/temp&quot;)));

    //2.创建文件上传的核心类
    ServletFileUpload fileUpload = new ServletFileUpload(factory);
    //--判断当前文件上传的表单是否满足enctype=multipart/form-data
    if(!fileUpload.isMultipartContent(request)){
        throw new RuntimeException(&quot;请使用正确的文件上传表单上传数据！&quot;);
    }
    //--设置文件名解析时采用的编码
    fileUpload.setHeaderEncoding(&quot;utf-8&quot;);
    //--单个文件不能超过1MB
    fileUpload.setFileSizeMax(1024 * 1024);
    //--总大小不能超过10MB
    fileUpload.setSizeMax(10 * 1024 * 1024);
    //--设置上传文件的监听
    fileUpload.setProgressListener(new ProgressListener(){
        long begin = System.currentTimeMillis();
        public void update(long pBytesRead, long pContentLength,int pItems) {
    System.out.print(&quot;正在读取第&quot;+pItems+&quot;个上传项。。&quot;);
        System.out.print(&quot;共&quot;+pContentLength+&quot;字节。。&quot;);
        System.out.print(&quot;已经读取了&quot;+pBytesRead+&quot;字节。。&quot;);

        long leftBytes = pContentLength - pBytesRead;
        System.out.print(&quot;剩余&quot;+leftBytes+&quot;字节。。&quot;);

        long now = System.currentTimeMillis();
        long usetime = (now - begin)/1000 ;
        System.out.print(&quot;已经用时&quot; + usetime+&quot;秒。。&quot;);

        long speed = usetime == 0 ? 0 : pBytesRead / usetime / 1024;
        System.out.print(&quot;上传速度&quot; + speed+&quot;KB/s。。&quot;);

        double per = Math.round(pBytesRead * 10000.0 / pContentLength)/100.0;
        System.out.println(&quot;上传百分比&quot; + per + &quot;%。。&quot;);

        long lefttime = speed == 0 ? 0 : leftBytes /1024 / speed;
        System.out.println(&quot;大致剩余时间&quot;+lefttime+&quot;秒&quot;);

        request.getSession().setAttribute(&quot;progress&quot;, per);
        }

        });

    //--解析request得到FileItem的集合
    List&lt;FileItem&gt; items = fileUpload.parseRequest(request);

    //--遍历每个item分别做处理
    for(FileItem item : items){
        if(item.isFormField()){
            //普通字段项
            String name = item.getFieldName();
            String value = item.getString(&quot;utf-8&quot;);
            System.out.println(name+&quot;~&quot;+value);
        }else{
            //文件上传项
            String fname = item.getName();
            //--处理ie文件名bug
            if(fname.contains(&quot;\\&quot;)){
                fname = fname.substring(fname.lastIndexOf(&quot;\\&quot;)+1);
            }

            //--处理文件名 使其不会重复
            String savename = UUID.randomUUID().toString()+&quot;_&quot;+fname;

            //--文件分目录处理
            //----获取文件名的hash 转换为16进制字符串表现形式 由于文件名随机 所以 hash值也是散列的
            String hash = Integer.toHexString(savename.hashCode());

            //----如果hash不足8位则在前面拼接足够8位的0
            while(hash.length()&lt;8){
                hash += &quot;0&quot;;
            }
            //----遍历hash值字符串的每一个字符作为一级目录拼接
            String savepath = &quot;/WEB-INF/upload/&quot;;
            for(int i = 0;i&lt;hash.length();i++){
                savepath += (hash.charAt(i)+&quot;/&quot;);
            }
            //----创建出该目录
            new File(this.getServletContext().getRealPath(savepath)).mkdirs();

            //----得到输入流
            InputStream in = item.getInputStream();

            //----得到输出流 路径就是上面 hash拼接出的路径+文件名
            OutputStream out = new FileOutputStream(this.getServletContext().getRealPath(savepath + &quot;/&quot; +savename));

            //----输出数据到文件
            byte []  data = new byte[1024];
            int n = -1;
            while((n = in.read(data))!=-1){
                out.write(data,0,n);
            }

            //----关闭流
            in.close();
            out.close();

            //----删除缓存文件
            item.delete();
        }
    }

    } catch (FileSizeLimitExceededException e) {
        response.getWriter().write(&quot;文件大小超过限制！！&quot;);
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/事务/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/事务/" itemprop="url">事务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-22T13:19:55+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h3><p>事务指逻辑上的一组操作,组成这组操作的各个单元,要么全部成功,要么全部不成功.  </p>
<h3 id="管理事务"><a href="#管理事务" class="headerlink" title="管理事务"></a>管理事务</h3><p>1.数据库默认的事务<br>&nbsp;&nbsp;&nbsp;&nbsp;数据库默认支持事务的,但是数据库默认的事务是一条sql语句独占一个事务,这种模式,意义不大.<br>2.手动控制事务<br>&nbsp;&nbsp;&nbsp;&nbsp;如果希望自己控制事务也是可以的:</p>
<pre><code>start transaction;
---开启事务,在这条语句之后的所有的sql将处在同一个事务中,要么同时完成要么同时不完成.
.......
--事务中的sql在执行时,并没有真正修改数据库中的数据
commit;
--提交事务,将整个事务对数据库的影响一起发生
rollback;
--回滚事务,将这个事务对数据库的影响取消掉
</code></pre><p>3.JDBC中控制事务<br>&nbsp;&nbsp;&nbsp;&nbsp;当jdbc程序数据库获得一个Connection对象时,默认情况下这个Connection对象会自动向数据库提交在它上面发送的SQL语句,若想关闭这种默认提交方式,让多条SQL在一个事务中执行,可使用下列语句:</p>
<pre><code>conn.setAutoCommit(false);
--关闭自动连接后,conn将不会帮我们提交事务,在这个连接上执行所有的sql语句将处在同一个事务中,需要我们是手动的进行提交或回滚.
conn.commit();
--提交事务
conn.rollback();
--回滚事务
也可以设置回滚点回滚部分事务
SavePoint sp = conn.setSavePoint();
conn.rolback(sp);
--注意,回到回滚点后,回滚点之前的代码虽然没被回滚但是也没被提交,如果想起作用还要做commit操作.
</code></pre><h3 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h3><p>事务的四大特性是事务本身具有的特点,简称ACID.</p>
<pre><code>*原子性(Atomicity).
原子性是指事务是一个不可分割的工作单位,事务中的操作要么都发生,要么都不发生.
*一致性(Consistency)
事务前后数据的完整性必须保持一致
*隔离性(Isolation)
事务的隔离性是指多个用户并发访问数据库时,一个用户的事务不能被其它用户的事务锁干扰,多个并发事务之间数据要相互隔离.
*持久性
持久性是指一个事务一旦被提交,它对数据库中数据的改变就是永久性的,接下来即使数据库发生故障也不应该对其有任何影响.    
</code></pre><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>1.脏读:</p>
<pre><code>一个事务读取到另一个事务未提交的数据
---------------------------------
a    1000
b    1000
---------------------------------
a:
    start transaction;
    update account set money=money-100 where name=&apos;a&apos;;
    update account set money=money+100 where name=&apos;b&apos;;
----------------------------------------------------
b:
    start transaction;    
    select * from account;
    a    900
    b    1100
    commit;
------------------------------
a:
    rollback;
--------------------------------
b:
    select transaction;
    select * from account;
    a    1000
    b    1000
    commit;
</code></pre><p>2.不可重复读:<br>&nbsp;&nbsp;&nbsp;&nbsp;一个事务多次读取数据库中同一条记录,多次查询的结果不同(一个事务读取到另一个事务已经提交的数据)</p>
<pre><code>a    1000    1000    1000
-----------------------------
b:    start transaction;
    select 活期 from account where name = &apos;a&apos;;---活期存款:1000元
    select 定期 from account where name = &apos;a&apos;;---定期存款:1000元
    select 固定 from account where name = &apos;a&apos;;---固定资产:1000元
    ----------------------
    a:
        start transaction;
        update account set 活期=活期-1000 where name=&apos;a&apos;;
        commit;
        ------------------
    select 活期+定期+固定 from account where name=&apos;a&apos;;---总资产:2000元
</code></pre><p>3.虚读(幻读)<br>&nbsp;&nbsp;&nbsp;&nbsp;有可能出现,有可能不出现:一个事务多次查询整表数据,多次查询,由于有其他事务增删数据,造成的查询结果不同(一个事务读取到另一个事务已经提交的数据)</p>
<pre><code>a    1000
b    1000
--------------------------
d:
    start transaction;
    select sum(money) from account;---总存款3000元
    select count(*) from account;---总账户2个
    -----------------
    c:
        start transaction;
        insert into account values(&apos;c&apos;,3000);
        commit;
        ----------------
    select avg(mone) from account;---平均每个账户:2000元
</code></pre><h3 id="数据库的隔离级别"><a href="#数据库的隔离级别" class="headerlink" title="数据库的隔离级别"></a>数据库的隔离级别</h3><pre><code>数据库的四大隔离级别:
Read uncommitted;
---不做任何隔离,可能造成脏读 不能重复读 虚读(幻读)问题
Read Committed;
---可以防止脏读,但是不能防止不可重复读 虚读(幻读)问题
Repeatable Read;
---可以防止脏读 不可重复读,但是不能防止虚读(幻读)问题
Serializable;
---可以防止所有隔离性的问题,但是数据库就被设计为了串行化的数据库,性能很低
</code></pre><p>从安全性上考虑:</p>
<pre><code>Serializable &gt; Repeatable Read &gt; Read Committed &gt; Read uncommitted
</code></pre><p>从性能上考虑</p>
<pre><code>Read uncommitted &gt; Read committed &gt; Repeatable Read &gt;Serializable
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;其中Serializable性能太低用的不多,Read uncommitted安全性太低用的也不多,我们通常从Repeatable Read和Read committed中选择一个.<br>&nbsp;&nbsp;&nbsp;&nbsp;如果需要防止不可重复读选择Repeatable Read,如果不需要防止选择Read committed<br>&nbsp;&nbsp;&nbsp;&nbsp;数据库默认的隔离级就是Repeatable Read<br>&nbsp;&nbsp;&nbsp;&nbsp;Oracle数据库默认的隔离级别是Read committed</p>
<h3 id="操作数据库的隔离级别"><a href="#操作数据库的隔离级别" class="headerlink" title="操作数据库的隔离级别"></a>操作数据库的隔离级别</h3><p>1.查询数据库的隔离级别:</p>
<pre><code>select @@tx_isolation;
</code></pre><p>2.修改数据库的隔离级别:</p>
<pre><code>set[session/global] transaction isolation level xxxx;
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;不写默认是session,修改的是当前客户端和服务器交互时使用的隔离级别,并不会影响其他客户端的隔离级别<br>&nbsp;&nbsp;&nbsp;&nbsp;如果写成global,修改的是数据库默认的隔离级别(即新开客户端时,默认的隔离级别),并不会修改当前客户端和已经开启的客户端的隔离级别.</p>
<p>###数据库的锁  ###<br>1.共享锁<br>&nbsp;&nbsp;&nbsp;&nbsp;共享锁和共享锁可以共存,共享锁和排他锁不能共存,在非Serializable隔离级别下做查询不加任何锁, 在Serializable隔离级别下做查询加共享锁.<br>2.排他锁<br>&nbsp;&nbsp;&nbsp;&nbsp;排他锁和共享锁不能共存,排他锁和排他锁也不能共存,在任何隔离级别下做增删改都加排他锁.<br>3.死锁<br>&nbsp;&nbsp;&nbsp;&nbsp;当两边都是Serializable隔离级别时,两边都先进行查询,再尝试进行修改,则互相等待对方释放共享锁,都无法接着进行执行.<br>&nbsp;&nbsp;&nbsp;&nbsp;死锁的解决方法有两种办法:避免死锁,解决死锁.<br>&nbsp;&nbsp;&nbsp;&nbsp;mysql可以自动检测到死锁,错误退出一方执行另一方</p>
<h4 id="更新丢失问题"><a href="#更新丢失问题" class="headerlink" title="更新丢失问题"></a>更新丢失问题</h4><p>1.更新丢失问题的产生<br>&nbsp;&nbsp;&nbsp;&nbsp;两个并发的事务基于同一个查询结果进行修改,后提交的事务忽略了先提交的事务对数据库的影响,造成了先提交的事务对数据库的影响丢失,这个过程就叫做更新丢失.<br>2.更新丢失解决方案<br>&nbsp;&nbsp;&nbsp;&nbsp;将数据库设为Serializable隔离级别,但是我们一般不会将数据库设置为Serializable<br>&nbsp;&nbsp;&nbsp;&nbsp;在非Serializable下可以用乐观锁和悲观锁解决更新丢失.</p>
<pre><code>悲观锁:在查询时,手动的加排他锁,从而在查询时就排除可能的更新丢失.
乐观锁:在表中设计版本字段,在进行修改时,要求根据具体版本进行修改,并将版本字段+1,如果更新失败,说明更新丢失,需要重新进行更新.
总结:两种解决方案各有优缺点,如果查询多于修改用乐观锁,如果修改多于查询用悲观锁.
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/简单算法总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/简单算法总结/" itemprop="url">简单算法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-22T13:19:55+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h4><p>冒泡排序的基本思想是:<br>&nbsp;&nbsp;&nbsp;&nbsp;1.比较相邻的元素,如果第一个比第二个大,就交换它们两个.<br>&nbsp;&nbsp;&nbsp;&nbsp;2.对每一对相邻元素作同样的工作,从开始第一对到结尾的最后一对,在这一点,最后的元素应该会是最大的数.<br>&nbsp;&nbsp;&nbsp;&nbsp;3.针对所有的元素重复以上的步骤,除了最后一个.<br>&nbsp;&nbsp;&nbsp;&nbsp;4.持续每次对越来越少的元素重复上面的步骤,直到没有任何一对数字需要比较.<br><strong>实现性能:</strong><br>1.最差时间复杂度O(n^2)<br>2.最优时间复杂度O(n)<br>3.平均时间复杂度O(n^2)<br>4.最差时间复杂度O(n),需要辅助空间O(1)<br>&nbsp;&nbsp;&nbsp;&nbsp;例如,如果需要将一组数(n个数)以从小到大的顺序排序,那么就可以设计这样的冒泡方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//假设有5个数,总共比较4轮,</span><br><span class="line">//第一轮比较4次,第二轮比较3次,第三轮比较2次,第四轮比较1次</span><br><span class="line">public class BubbleSortDemo&#123;</span><br><span class="line">	static void bubbleSort(int[] arr)&#123;</span><br><span class="line">		for(int i = 0;i &lt; arr.length-1;i++)&#123;</span><br><span class="line">			for(int j = 0;j &lt; arr.length-1-i;j++)&#123;</span><br><span class="line">				if(arr[j]&gt;att[j+1])&#123;</span><br><span class="line">					int temp = arr[j];</span><br><span class="line">					arr[j] = arr[j+1];</span><br><span class="line">					arr[j+1] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		int[] arr = new int[] &#123;1,2,5,7,12,4&#125;;</span><br><span class="line">		//printArray(arr);</span><br><span class="line">		bubbleSort(arr);</span><br><span class="line">		for(int a:arr) &#123;</span><br><span class="line">			System.out.print(a);</span><br><span class="line">		&#125;</span><br><span class="line">		//printArray(arr);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>选择排序算法,顾名思义就是直接从排序数组中选择一个最小(或最大的)数字.每次都拿一个最小数字出来,顺序放入新数组中,直到全部拿完.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class ChoiceDemo&#123;</span><br><span class="line">	static void choice(int[] arr)&#123;</span><br><span class="line">		//每个数都要执行一次选择排序</span><br><span class="line">		for(int i = 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">			//剩下的数组元素每个也要执行一次选择排序</span><br><span class="line">			for(int j = i+1;j&lt;arr.length;j++)&#123;</span><br><span class="line">				//按从小到大排序</span><br><span class="line">				int temp;</span><br><span class="line">				if(arr[i]&gt;arr[j])&#123;</span><br><span class="line">					temp = arr[i];</span><br><span class="line">					arr[i] = arr[j];</span><br><span class="line">					arr[j] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public staitc void main(String[] args)&#123;</span><br><span class="line">		int[] arr = new int[]&#123;1,12,34,5,8&#125;;</span><br><span class="line">		choice(arr);</span><br><span class="line">		for(int a:arr)&#123;</span><br><span class="line">			System.out.println(a);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>二分查找又称折半查找,假设表中元素是按升序排序,将表中间位置的元素与查找关键字比较,如果两者相等,则查找成功,否则利用中间位置记录将表分成前.后两个子表,如果中间位置的元素大于要查找的关键字,则进一步查找前一个子表,否则进一步查找后一个子表,重复以上过程,直到找到满足条件的记录,使查找成功,或直到子表不存在为止,此时查找不成功.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class DichotomyDemo&#123;</span><br><span class="line">	static int foldFind(int[] arr,int key)&#123;</span><br><span class="line">		int min = 0;</span><br><span class="line">		int max = arr.length-1;</span><br><span class="line">		int mid = 0;</span><br><span class="line">		//必须判断min&lt;max</span><br><span class="line">		while(min&lt;max)&#123;</span><br><span class="line">			mid = (min_max)/2;</span><br><span class="line">			if(key&lt;arr[mid])&#123;</span><br><span class="line">				max = mid-1;</span><br><span class="line">			&#125;else if(key&gt;arr[mid])&#123;</span><br><span class="line">				min = mid+1;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				return mid;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">	int[] arr = new int[]&#123;1,2,3,4,5,6,7,8&#125;;</span><br><span class="line">	System.out.println(foldFind(arr,6));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/tomcat相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/tomcat相关/" itemprop="url">tomcat相关</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-22T13:19:55+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="tomcat的下载安装配置"><a href="#tomcat的下载安装配置" class="headerlink" title="tomcat的下载安装配置"></a>tomcat的下载安装配置</h3><p>1.下载tomcat<br>&nbsp;&nbsp;&nbsp;&nbsp;下载地址<a href="http://tomcat.apache.org" target="_blank" rel="noopener">http://tomcat.apache.org/</a><br>&nbsp;&nbsp;&nbsp;&nbsp;下载时请注意,不同版本的区别:<br>&nbsp;&nbsp;&nbsp;&nbsp;.zip为压缩版,解压后即可使用.<br>&nbsp;&nbsp;&nbsp;&nbsp;.exe为安装版,安装后使用.<br>2.安装tomcat<br>&nbsp;&nbsp;&nbsp;&nbsp;(1).解压<br>&nbsp;&nbsp;&nbsp;&nbsp;将解压版.zip包拷贝到要安装的目录下,解压,改名为tomcat7.0.<br>&nbsp;&nbsp;&nbsp;&nbsp;注意,安装目录中不允许有空格和中文<br>3.配置环境<br>tomcat是java写的,需要jdk支持,故要配置java环境 ,然后配置tomcat,此处值介绍如何配置tomcat环境<br>计算机 &gt; 属性 &gt; 高级系统设置 &gt; 环境变量 &gt; 新建 &gt; 变量名<br>变量名设为:TOMCAT_HOME,值为tomcat安装的根目录<br>4.启动tomcat<br>&nbsp;&nbsp;&nbsp;&nbsp;通过[tomcat]/bin/startup.bat文件 启动tomcat服务器<br>&nbsp;&nbsp;&nbsp;&nbsp;通过[tomcat]/bin/shutdown.bat文件 关闭tomcat服务器<br>&nbsp;&nbsp;&nbsp;&nbsp;浏览器访问在<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 如果能够看到tomcat的首页就证明tomcat安装配置成功<br>5.安装常见问题<br>&nbsp;&nbsp;&nbsp;&nbsp;(1).端口占用问题:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.看是否一句你打开tomcat,或是tomcat在关闭时没有正确的关闭,可以运行shutdown.bat命令,然后再次打开.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.可以在cmd窗口中使用netstat -ano命令查询出哪个程序占用了端口,根据pid,在任务管理器的服务中找到此pid,结束这个程序后再启动tomcat即可.<br>&nbsp;&nbsp;&nbsp;&nbsp;(2).安装路径问题<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tomcat安装路径中一定不能有中文和空格,坑呢一时半会没问题,可能不知道什么时候可能出现意外.<br>6.修改默认的端口号<br>&nbsp;&nbsp;&nbsp;&nbsp;服务器在启动之后默认监听的是8080端口号,每次访问时都需要在IP地址或者主机名后面跟上这个端口号,如果想省略不写,可以将8080改为80即可.<br>&nbsp;&nbsp;&nbsp;&nbsp;找到[tomcat]/conf/server.xml文件并打开,第70行  </p>
<pre><code>&lt;Connection port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
    connectionTimeout=&quot;20000&quot;
    redirectPort=&quot;8443&quot;/&gt;
---------------------------------
将其中的8080改为80即可      
</code></pre><h3 id="tomcat的目录结构"><a href="#tomcat的目录结构" class="headerlink" title="tomcat的目录结构"></a>tomcat的目录结构</h3><pre><code>bin---存放tomcat批处理文件的目录
conf---存放tomcat配置文件的目录
lib---存放tomcat运行时依赖的jar包
logs---存放tomcat运行时产生的日志文件的目录
temp---存放tomcat运行时产生的临时文件的目录
webapps---这是和开发人员关系最大的目录,是用来存放web应用的目录,我们开发的web资源要保存在这个目录下,外界就可以访问了.
work---存放tomcat服务器运行时产生的工作文件的目录
</code></pre><h3 id="部署web应用到虚拟主机中"><a href="#部署web应用到虚拟主机中" class="headerlink" title="部署web应用到虚拟主机中"></a>部署web应用到虚拟主机中</h3><p>1.方式一:(了解)<br>&nbsp;&nbsp;&nbsp;&nbsp;在[tomcat]/conf/server.xml中的<host></host>标签内部,添加一个Context标签,配置如下: </p>
<pre><code>&lt;Context path=&quot;/news&quot; docBase=&quot;C:\Users\hh\Desktop\news&quot;&gt;
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;其中path属性指定WEB应用的虚拟路径,第一个斜杠可以省略,docBase用来指定WEB应用真实路径<br>&nbsp;&nbsp;&nbsp;&nbsp;可以在浏览器输入相应的虚拟路径网址访问资源,比如:<a href="http://localhost/news/regist/regist.html" target="_blank" rel="noopener">http://localhost/news/regist/regist.html</a><br>&nbsp;&nbsp;&nbsp;&nbsp;这种方式每次配置完后都需要重新启动服务器才可以生效,所以不推荐!!!<br>2.方式二:<br>&nbsp;&nbsp;&nbsp;&nbsp;在[tomcat]/conf/Catalina/host目录下添加一个xxx.xml文件,文件的名字就是WEB应用的虚拟路径,文件中添加内容如下:<br>&nbsp;&nbsp;&nbsp;&nbsp;比如:我们先创建news2文件夹,在[tomcat]/conf/Catalina/localhost目录下添加一个news2.xml文件,文件内容如下:  </p>
<pre><code>&lt;Context docBase=&quot;C:\Users\hh\Desktop\news2&quot;/&gt;
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;这种方式配置后不需要重启服务器就可以起到作用!<br>3.方式三:<br>&nbsp;&nbsp;&nbsp;&nbsp;直接将WEB应用放在localhost主机默认管理的目录下即可!<br>&nbsp;&nbsp;&nbsp;&nbsp;这里localhost管理的目录是webapps目录,[tomcat]/conf/server.xml中第124行可以看到,当然也可以修改,一般都不要动  </p>
<pre><code>&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;文件夹的名字成为web应用的虚拟路径,无须重启服务器<br>&nbsp;&nbsp;&nbsp;&nbsp;比如:创建news3,并放入[tomcat]/webapps中,即可访问</p>
<h3 id="配置缺省的WEB应用"><a href="#配置缺省的WEB应用" class="headerlink" title="配置缺省的WEB应用"></a>配置缺省的WEB应用</h3><p>1.第一种配置方式 只需要将path的值配置为空(“ “)即可<br>2.第二种配置方式 只需要将xxx.xml文件的名字配置为ROOT即可.<br>3.第三种配置 方式 只需要将webapps目录下WEB应用文件夹的名字配置为ROOT即可.<br>注意:如果三种方式都配置了缺省WEB应用,优先级规则是:第一种 &gt; 第二种 &gt; 第三种</p>
<h3 id="配置虚拟主机"><a href="#配置虚拟主机" class="headerlink" title="配置虚拟主机"></a>配置虚拟主机</h3><p>第一步:在[tomcat]/conf/server.xml文件的Engine标签内部添加一个Host标签,配置如下(同时在[tomcat]/目录下创建baidu文件夹,并放入一个web应用)      </p>
<pre><code>&lt;Host name=&quot;www.baidu.com&quot; appBase=&quot;baidu&quot;&gt;&lt;/Host&gt;  
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;其中name是必须存在的属性,用来指定虚拟主机的名称.<br>&nbsp;&nbsp;&nbsp;&nbsp;appBase可选属性,用来指定虚拟主机默认管理的目录,如果没有配置该属性,表示当前主机没有默认管理的目录!<br>第二步:<br>&nbsp;&nbsp;&nbsp;&nbsp;配置完后,还需要在DNS服务器中配置主机名和IP地址的映射关系,但是DNS服务器一般不能修改,可以通过hosts文件进行模拟,在下面的路径C:\Windows\System32\drivers\etc中找到hosts文件.<br>&nbsp;&nbsp;&nbsp;&nbsp; 在最后一行加入配置:(IP和网址之间是Tab键)  </p>
<pre><code>127.0.0.1    www.baidu.com
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;在浏览器输入路径,如:<a href="http://www.baidu.com/news3/1.html" target="_blank" rel="noopener">www.baidu.com/news3/1.html</a><br>&nbsp;&nbsp;&nbsp;&nbsp;注意:当可以上网的时候,很有可能你输入的网址不能生效,直接去访问百度去了,这时候需要清dns缓存,打开cmd窗口,输入ipconfig/flushns,浏览器清缓再次打开即可.</p>
<h3 id="配置默认虚拟主机"><a href="#配置默认虚拟主机" class="headerlink" title="配置默认虚拟主机"></a>配置默认虚拟主机</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;当使用IP访问服务器时,会访问哪台主机呢?<br>&nbsp;&nbsp;&nbsp;&nbsp;在[tomcat]/conf/server.xml文件的Engine标签上有一个属性defaultHost,可以通过此属性改变默认虚拟主机,比如(默认是localhost)  </p>
<pre><code>&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;www.baidu.com&quot;&gt;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">fireworks</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fireworks</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
