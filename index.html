<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="ghost">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="ghost">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ghost">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>ghost</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ghost</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/15/面试总结二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/15/面试总结二/" itemprop="url">面试总结二</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-15T18:40:00+08:00">
                2018-05-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>hashMap为什么线程不安全</strong><br>hashMap在并发时可能出现的问题主要是两方面</p>
<ul>
<li>首先如果多个线程同时使用put方法添加元素,而且假设正好存在两个put的key发生碰撞(根据hash值计算的存储位置一样),这样最终就会发生一个线程的put的数据发生覆盖.</li>
<li>第二就是如果多个线程同时检测到元素个数超过数组大小*加载因子,这样就会发生多个线程同时对Node数组进行扩容,都在重新计算元素位置以及复制数据,但是最终只有一个线程扩容后的数组会赋给table,也就是说其他线程都会丢失,并且各自线程put的数据也丢失.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/12/面试总结一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/12/面试总结一/" itemprop="url">面试总结一</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-12T13:27:05+08:00">
                2018-05-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h4><p><code>数据结构中有数组和链表来实现对数据的存储,但这两者基本上是两个极端</code><br><strong>数组</strong><br>数组存储区间是连续的,占用内存严重,故空间复杂很大,但数组的二分查找时间复杂度小,为O(1);数组的特点是:寻址容易,插入和删除困难.<br><strong>链表</strong><br>链表存储区间离散,占用内存比较宽松,故空间复杂度很低,但时间复杂度很大,达(N).链表的特点是:寻址困难,插入和删除容易.<br><strong>哈希表</strong><br>寻址容易,插入删除也容易的数据结构,也不会占用太多的内存空间.<br>1.哈希表是由数组和链表组成的,一个数组中,每个元素存储的是一个链表的头结点,一般情况下是通过hash(key)%len获得,也就是元素的key的哈希值对数组长度取模得到的,比如数组长度的len为16,key为12,28,12%16=12,28%16=12,所以key都存储到数组下标为12的位置.<br>2.hashMap其实是一个线性的数组实现的,所以理解为其存储数据的容器就是一个线性数组,这可能让我们很不解,一个线性的数组怎么实现按键值对实现的一个基础bean,我们上面说到HashMap的基础就是一个线性数组,这个数组就是Entry[],Map里面的内容都保存在Entry[]里面.<br><code>transient Entry[] table;</code><br><strong>总结</strong><br>1.在JDK1.6,JDK1.7中,HashMap采用位桶+链表实现,即使用链表处理冲突,同一个hash值得链表都存储在一个链表里,但是当位于一个桶中的元素较多,即hash值相等的元素较多时,通过key值依次查找的效率较低,而JDK1.8中,HashMap采用位桶+链表+红黑树实现,当链表长度超过阈值(8)时,将链表转换为红黑树,这样大大减少了查找时间.<br><strong>红黑树</strong><br>红黑树是每个节点都带有颜色属性的二叉查找树,颜色为红色或黑色,在二叉查找树强制一般要求以外,对于任何有效的红黑树我们增加了如下的额外要求:<br>1.节点是红色或黑色.<br>2.根是黑色.<br>3.所有叶子节点都是黑色(叶子是NIL节点).<br>4.每个红色节点必须有两个黑色的子节点(从每个叶子到根的路径上不能有两个连续的红色节点).<br>5.从任一节点到每个叶子节点的所有简单路径都包含相同数目的黑色节点.<br><strong>为什么需要加载因子</strong><br>加载因子(默认是0.75),因为如果填充比很大,说明利用的空间很多,如果一直不进行扩容的话,链表就会越来越长,这样查找的效率很低,因为链表的长度很大(当然最新版使用了红黑树改进了很多),扩容之后,将原来链表数组的每一个链表分成奇偶两个子链表分别挂在新的链表数组的散列位置,这样就减少了每个链表的长度,增加查找效率.</p>
<h4 id="HashMap的存取实现"><a href="#HashMap的存取实现" class="headerlink" title="HashMap的存取实现"></a>HashMap的存取实现</h4><p>既然是线性数组,为什么能随机存取?这里HashMap用了一个小算法,大致是这样实现的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//存储时:</span><br><span class="line">int hash = key.hashCode();</span><br><span class="line">int index = hash % Entry[].length;</span><br><span class="line">Entry[index] = value;</span><br><span class="line">//取值时:</span><br><span class="line">int hash = key.hashCode();</span><br><span class="line">int index = hash % Entry[].length;</span><br><span class="line">return Entry[index];</span><br></pre></td></tr></table></figure></p>
<p><strong>put</strong><br>1.疑问:如果两个key通过hash % Entry[].length得到的index相同,会不会有覆盖的危险?<br>答:这里HashMap里面用到链式数据结构的一个概念.上面我们提到Entry里面有一个next属性,作用是指向下一个Entry,打个比方,第一个键值对A进来,通过计算其key的hash得到的index=0,记做:Entry[0] = A.一会后又进来一个键值对B,通过计算其index也等于0,HashMap会这样做:B.next = A,Entry[0] = B,如果又进来C,index也等于0,那么C.next = B,Entry[0] = C;这样我们会发现index = 0的地方其实存取了A,B,C三个键值对,他们通过next这个属性链接在一起,所以疑问不用担心,也就是说数组中存储的是最后插入的元素.<br>2.当然HashMap里面包含了一些优化方面的实现,比如:Entry[]的长度一定后,随着map里面数据越来越长,这样同一个index的链就会很长,会不会影响性能?HashMap里面设置一个因子,随着map的size越来越大,Entry[]会以一定的规则加长长度.<br><strong>null key</strong><br>null key总是存放在Entry[]数组的第一个元素中.<br><strong>解决hash冲突的办法</strong><br>1.开放定址法(线性探测再散列,二次探测再散列,伪随机探测再散列)<br>2.再哈希法<br>3.链地址法<br>4.建立一个公共溢出区<br><strong>注</strong>java中HashMap的解决方法就是采用的链地址法 </p>
<h4 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h4><p>HashMap和HashTable都实现了Map接口,但决定用哪一个之前先要弄清楚它们之间的分别,主要的区别有:线程安全性,同步,以及速度.<br>1.HashMap几乎可以等价于HashTable,除了HashMap是非synchronized的,并可以接受null(HashMap可以接受为null的键值(key)和值(value)而HashTable则不行).<br>2.HashMap是非synchronized,而Hashtable是synchronized,这意味着Hashtable是线程安全的,多个线程可以共享一个Hashtable;而如果没有正确同步的话,多个线程是不能共享HashMap的,Java 5提供了ConcurrentHashMap,它是HashTable的替代,比HashTable的扩展性更好.<br>3.另一个区别就是HashMap的迭代器是fail-fast迭代器,而HashTable的enumerator迭代器不是fail-fast的,所以当有其他线程改变了HashMap的结构(增加或者移除元素),将会抛出ConcurrentModificationException,但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常,但这并不是一个一定发生的行为,要看JVM.这条同样也是Enumeration和Iterator的区别.<br>4.由于HashTable是线程安全的也是synchronized,所以在单线程环境下它比HashMap要慢,如果你不需要同步,只需要单线程,那么使用HashMap性能要好过HashTable.<br>5.HashMap不能保证随着时间的推移Map中的元素次序是不变的.</p>
<h3 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h3><p>1.面向对象的概念和应用已经超越了程序设计和软件开发,扩展到很,宽的范围,如数据库系统,交互式界面,应用结构,应用平台,分布式系统,网络管理结构,CAD技术,人工智能等领域.<br>2,起初,”面向对象”是指在程序设计中采用封装,继承,多态和抽象等设计方法,可是,这个定义显然不再适用,面向对象的思想已经涉及到软件开发的哥哥方面,如,面向对象分析(OOA),面向对象设计(OOD),面向对象的编程实现(OOP).<br><strong>注:</strong></p>
<ul>
<li>面向对象的分析(OOA):陈述需求,分析者必须同用户一块工作提炼需求,因为这样才表示了用户的真实意图,其中涉及对需求的分析及查找丢失的信息.</li>
<li>面向对象的设计(OOD):把分析阶段的需求转变成符合成本和质量要求的,抽象的系统实现方案的过程,从面向对象分析到面向对象设计,是一个逐渐扩充模型的过程.</li>
<li>面向对象的编程实现:采用面向对象方法挨罚软件的基本目的和主要优点是通过重用提高软件的生产率.<br>3,类是对象的抽象,对象是类的具体实现.<br>4,封装,继承,多态.</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>1.数据结构相互之间的关系称为结构,有四类基本结构:集合,线性结构,树形结构,图状结构.集合结构除了属于一种类型外,别无其他关系,线性结构:元素之间存在一对一关系常见类型有:数组,链表,队列,栈,它们之间在操作上有所区别.例如:链表可在任意插入和删除元素.<br>2.常用数据结构:数组(静态数组,动态数组),线性表,链表(单向链表,双向链表,循环链表),队列,栈,树(二叉树,查找树,平衡树,线索,堆),图等的定义,存储和操作.  </p>
<ul>
<li>数组:一个数组可以分解成多个数组元素,这些数组元素可以是基本数据类型或是构造数据类型,因此按数组元素类型不同,数组又分为数值数组,字符数组,指针数组,结构数组等.</li>
<li>栈:栈是只能在某一端插入和删除的特殊线性表,它按照先进后出的原则存储数据,先进入的数据被压入栈底,最后的数据在栈顶,需要读数据的时候从栈顶开始弹出数据,最后一个数据被第一个读出来.</li>
<li>队列:一种特殊的线性表,它只允许在表的前端进行删除操作,而在标的后端进行插入操作,进行插入操作的端称为队尾,进行删除操作的端称为队头,队列中没有元素时,称为队空.</li>
<li>链表:链表是一种物理单位上非连续,非顺序的存储结构,数据元素的逻辑顺序是通过链表中的指针链接次序实现的,链表由一系列结点(链表中的每一个元素称为结点)组成,结点可以在运行时动态生成,每个结点包含两个部分:一个存储数据元素的数据域,另一个是存储下一个结点地址的指针域.  </li>
<li>树:树是包含n(n&gt;0)哥结点的有穷集合K,且在K中定义了一个关系N,N满足一下条件:<br>1).有且仅有一个结点KO,他对于关系N来说没有前驱,城KO为树的根节点,简称为根.<br>2).除KO外,K中的每个结点,对于关系N来说有且仅有一个前驱.<br>3).K中各结点,对关系N来说可以有m各后继结点(m&gt;=0).</li>
<li>图:图是由结点的有穷集合V和边的集合E组成,其中,为了与树形结构加以区别,在图结构中常常将结点称为顶点,边是顶点的有序偶对,若两个顶点之间存在一条边,就表示这两个顶点具有相邻关系.  </li>
<li>堆:堆是一种特殊的树形数据结构,每个结点都有一个值,通常我们所说的堆的数据结构,是指二叉堆,堆的特点是根据结点的值最小(或最大),且根结点的两个子树也是一个堆.  </li>
<li>散列表:若结构中存在关键字和K相等的记录.则该记录必定在f(K)的存储位置上,由此,不需比较便可直接取得所查记录,称这个对应关系f为散列函数,按这个思想建立的表为散列表.<h3 id="spring在什么情况下线程不安全"><a href="#spring在什么情况下线程不安全" class="headerlink" title="spring在什么情况下线程不安全"></a>spring在什么情况下线程不安全</h3>1.Spring作为一个IOC/DI容器,帮助我们管理了许许多多的”bean”,但其实,Spring并没有保证这些对象的线程安全,需要由开发者自己编写解决线程安全问题的代码.<br>2.我们交由Spring管理的大多数对象其实都是一些无状态的对象,这种不会因为多线程而导致状态被破坏的对象适合Spring的默认scope,每个单里的无状态对象都是线程安全的(也就是说只要是无状态的对象,不管单例多例都是线程安全的,不过单例毕竟节省了不断创建对象与GC的开销).<br>3.无状态的对象即是自身没有状态的对象,自然也就不会因为多个线程的交替调度而破坏自身状态导致线程安全问题,无状态对象包括我们经常使用DO,DTO,VO这些只作为数据的实体模型的贫血对象,还有Service,DAO和Controller,这些对象并没有自己的状态,它们只是用来执行某些操作的.例如,每个DAO提供的函数都只是对数据的CRUD,而且每个数据库Connection都作为函数的局部变量(局部变量是在用户栈中的,而且用户栈本身就是线程私有的内存区域,所以不存在线程安全为题),用完即关(或交还给连接池).<br>4.有人可能认为,我使用request作用域不就可以避免每个请求之间的安全问题了吗?这是完全错误的,因为Controller默认是单例的,一个Http请求是会被多个线程执行的,这就又回到了线程安全问题.当然,你可以把Controller的scope改成prototype,但是Spring MVC对请求的拦截粒度是基于每个方法的,所以把Controller设为多例将会频繁的创建与回收对象,严重影响到了性能.  5.Spring根本没有对bean的多线程安全问题作出任何保证与措施,对于每个bean的线程安全问题,根本原因是每个bean自身的设计,不要在bean中声明任何有状态的实例变量或类变量,如果必须如此,那么就只能使用ThreadLocal把变量变为线程私有的,如果bean的实例变量或类变量需要在多个线程之间共享,那么就只能使用synchronized,lock,CAS等这些实现线程同步的方法了.<br><strong>注</strong><br>1.有状态对象就是有数据存储功能,有状态对象就是实例变量对象,可以保存数据,是非线程安全的,在不同方法调用间不保留任何状态.其实就是有数据成员的对象.<br>2.无状态就是一次操作,不能保存数据,无状态对象,就是没有实例变量的对象,不能保存数据,是不变类,是线程安全的,具体就是只有方法没有数据成员的对象,或者有数据成员但是数据成员是可读的对象.  <h3 id="Mysql的数据引擎"><a href="#Mysql的数据引擎" class="headerlink" title="Mysql的数据引擎"></a>Mysql的数据引擎</h3>Mysql的数据库引擎是InnoDB引擎,增加了事物处理,改进全文本搜索等的支持.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/12/面试一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/12/面试一/" itemprop="url">面试一</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-12T06:27:50+08:00">
                2018-05-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/11/spring及springMVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/11/spring及springMVC/" itemprop="url">spring及springMVC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-11T07:44:37+08:00">
                2018-05-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="spring的MVC执行原理"><a href="#spring的MVC执行原理" class="headerlink" title="spring的MVC执行原理"></a>spring的MVC执行原理</h3><p>1.spring mvc将所有的请求都提交给DispatcherServlet,它会委托应用程序的其他模块负责请求,进行真正的处理过程.<br>2.DispatcherServlet查询一个活多个HandlerMapping,找到处理请求的Controller<br>3.DispatcherServlet将请求提交到目标Controller<br>4.Controller进行业务逻辑处理后,会返回一个ModelAndView<br>5.dispatcher查询一个或多个ViewResolver视图解析器,找到ModelAndView对象指定的视图对象<br>6.视图对象负责渲染返回给客户端</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/07/python爬虫搜索引擎学习心得/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/07/python爬虫搜索引擎学习心得/" itemprop="url">python爬虫搜索引擎学习心得</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-07T18:07:29+08:00">
                2018-05-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="pyton爬虫打造搜索引擎的学习心得"><a href="#pyton爬虫打造搜索引擎的学习心得" class="headerlink" title="pyton爬虫打造搜索引擎的学习心得"></a>pyton爬虫打造搜索引擎的学习心得</h4><p>1.创建虚拟机：virtualenv scrapytest<br>2.启动虚拟机:进入虚拟机：cd scrapytest然后cd Scripts然后执行activate.bat,如果退出虚拟机则执行deactivate.bat<br>3.用python3.5创建虚拟机：在虚拟环境scrapytest下Scripts下运行virtualenv -p D:\WorkSpace\python3.5.3\python.exe scrapypy3<br>4.创建python项目：在进入虚拟机的情况下，执行scrapy startproject ArticleSpider创建python项目<br>5.镜像：<a href="https://pypi.douban.com/simple/" target="_blank" rel="noopener">https://pypi.douban.com/simple/</a><br>6.安装django:先下载压缩包，解压到与python同目录下，进入django目录，执行命令：python setup.py<br>7.创建python项目：在进入虚拟机的情况下，执行scrapy startproject ArticleSpider创建python项目<br>8.爬取网站：进入项目根目录，然后执行scrapy genspider jobbole blog.jobbole.com<br>9.启动spider:例如启动jobbole,需要进入项目根目录，然后安装pypiwin32,执行命令pip install pypiwin32,然后执行scrapy crawl jobbole<br>10.要在命令行爬取数据，例如爬取<a href="http://www.jobbole.com/网页的数据，执行命令scrapy" target="_blank" rel="noopener">http://www.jobbole.com/网页的数据，执行命令scrapy</a> shell <a href="http://www.jobbole.com/" target="_blank" rel="noopener">http://www.jobbole.com/</a><br>11.安装requests库，进入项目根目录，执行pip install requests<br>12.爬虫:自动获取网站数据的程序,关键是批量的获取<br>13.反爬虫:使用技术手段防止爬虫程序的方法<br>14.误伤:反爬技术将普通用户识别为爬虫,如果误伤过高,效果再好也不能用<br>15.拦截:成功拦截爬虫,一般拦截率越高,误伤率越高<br>16.反爬虫的目的:<br>    1).初级爬虫:简单粗暴,不管服务器压力,容易弄挂网站;<br>    2).数据保护;<br>    3).失控的爬虫:由于某些情况下,忘记或者无法关闭的爬虫<br>    4).商业竞争对手<br>17.安装随机切换user-agent进入虚拟环境中,执行pip install fake-useragent<br>18.西刺免费ip代理:提供了好多免费ip代理<br>19.安装selenium:pip install selenium(Selenium也是一个用于Web应用程序测试的工具。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。)<br>20.部署环境：在项目路径下执行scrapy-deploy bobby -p ArticleSpider<br>21.爬取jobbole网站命令:scrapy genspider jobbole blog.jobbole.com<br>22.在命令行查看爬取到的数据：先安装pypiwin32:pip install -i <a href="https://pypi.douban.com/simple/" target="_blank" rel="noopener">https://pypi.douban.com/simple/</a> pypiwin32,然后再执行scrapy crawl jobbole<br>23,在cmd命令下查看爬取数据：1).scrapy shell <a href="http://web.jobbole.com/94332/" target="_blank" rel="noopener">http://web.jobbole.com/94332/</a><br>2).title = response.xpath(“/html/body/div[1]/div[3]/div[1]/div[1]/h1”)<br>3). title<br>4). 查看title的值执行title.extract()<br>5). 查看title的值执行title.extract()[0]<br>24.安装图片库 进入虚拟环境执行：pip install -i <a href="https://pypi.douban.com/simple/" target="_blank" rel="noopener">https://pypi.douban.com/simple/</a> pillow<br>25.安装数据库驱动：pip install mysqlclient<br>26.在article虚拟环境中安装elasticsearch,执行命令：pip install elasticsearch-dsl<br>27.连接远端服务器：telent localhost 8080(8080是端口号)<br>28.爬虫停止，暂停：在项目中创建一个文件夹job_info,然后在控制台启动虚拟环境，执行scrapy crawl lagou -s JOBDIR=job_info/001<br>29.分布式爬虫的优点：<br>1).充分利用多机器的宽带加速爬取<br>2).充分利用多机的ip加速爬取速度</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/02/数据库优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/数据库优化/" itemprop="url">数据库优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-02T14:39:35+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h3><p> 要解决数据量大的问题，是避不开数据库优化的，数据库优化可以在不增加硬件的情况下提高处理效率，这是一种用技术换金钱的方式，数据库优化的方法非常多，常用的由表结构化，SQL语句优化，分区和分表，索引优化，适应存储过程代替直接操作等，另外有时候合理使用冗余也能获得非常好的效果。  </p>
<ul>
<li>表结构优化<br>表结果优化是数据库中最基础也是最重要的，如果表结构优化得不合理，就可能导致严重的性能问题，具体怎么设计更合理也没有固定不变的准则，需要根据实际情况具体处理。  </li>
<li>SQL语句优化<br>SQL语句优化也是非常重要的，基础的SQL优化是语法层面的优化，不过更重要的是处理逻辑的优化，这也需要根据实际情况具体处理，而且要和索引缓存等配合使用。不过SQL优化有一个通用的做法就是，首先要将涉及大数据的业务的SQL语句执行时间详细记录下来，其次通过仔细分析日志（同一条语句对不同条件的执行时间也可能不同，这点也需要仔细分析）找出需要优化的语句和其中的问题，然后再有的放矢地优化，而不是不分重点对每条语句都花同样的时间和精力优化。 </li>
<li>分区<br>当数据量变多的时候，如果可以分区或者分表，那将起到非常好的效果，当一张表中的数据量变多的时候操作速度就变慢了，所以很容易想到的就是将数据分到多个表中保存，但是这么做之后操作起来就麻烦了，像操作（增删查改）一个数据还需要先找到对应的表，如果涉及多个表还得跨表操作。其实在常用的数据库中可以不分表二达到跟分表类似的效果，那就是分区，分区就是将一张表中的数据按照一定的规则分到不同的区来保存，这样在查询数据时如果数据在同一个区内那么可以只对一个区的数据进行操作，这样操作的数据量更少，速度更快，而且这种方法对程序是透明的，程序不需要做任何改动。  </li>
<li>分表<br>如果一个表中的数据可以分为几种固定不变的类型，而且如果同时对多种类型共同操作的情况不多，那么都可以通过份表来处理，这也需要具体情况具体对待。笔者之前对一个业务系统进行重构开发时就将其中保存工人工作卡片的数据表分成了三个表，并且对每个表进行分区，在同时使用缓存（主要用于在保存和修改时对其他表的数据获取中，如根据工人Id获取工人姓名，工人类别，所在单位，所在工段及班组等信息），索引，SQL优化等的情况下操作速度比原来提高了100倍以上，那时的分表是按照工作卡片的类型来划分的，因为当时的要求是要保留所有的记录，比如，修改了卡片的信息，则需要保存是谁在什么时候对卡片进行修改，修改前的数据是什么，添加删除也一样，这种需求一般的做法就是用一个字段来做卡片状态的标志位，将卡片分为不同的类型。不过这里由于数据量非常大所以就把卡片分别保存到了三个表中，第一个表保存正常卡片，第二个表保存删除后的卡片，第三个表保存修改之前的卡片，并且对每个表都进行了分区，由于报表都是按月份，季度，半年和年来做的，所以分区是按月份来分的，每个月一个分区，这样问题就解决了。<br>另外一种分表的方法是将一个表中不同类型的字段分到不同的表中保存，这么做最直接的好处就是增删查改数据的时候锁定的范围变小了，没被锁定的表中的数据不受影响，如果一个表的操作频率很高，在增删改其中一部分字段数据的同时另一部分字段也可能被操作，而且（主要指查询）用不到被增删改的字段，那么就可以把不同类型的字段分贝保存到不同的表中，这样就减少操作时锁定数据的范围了，不过这样分表之后，如果需要查询完整的数据就得使用多表操作了.  </li>
<li>索引优化<br>索引的大致原理就是数据发生变化（增删改）的时候就预先制定字段的顺序排列后保存到一个类似表的结构中，这样在查找索引字段为条件的记录时就可以很快的从索引中找到对饮记录的指针并从表中获取到记录，这样速度就快多了。不过索引也是一把双刃剑，它在提高查询速度的同时也降低了增删改的速度，因为每次数据的变化都需要更新相应的索引，不过合理使用索引对提高查询速度的效果非常明显，所以对哪些字段使用索引，使用什么类型的索引都需要仔细琢磨，并且最好再做一些测试。  </li>
<li>使用存储过程代替直接操作<br>在操作过程复杂而且调用频率高的业务中，可以通过使用存储过程代替直接操作来提高效率，因为存储过程只需要编译一次，而且可以在一个存储过程里面做一些复杂的操作。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/02/redis第一篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/redis第一篇/" itemprop="url">redis第一篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-02T10:05:08+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p><code>Redis是一个开源,内存数据结构存储,用作数据库,缓存和消息代理,支持数据结构,如字符串,散列,列表,集合,具有范围查询的排序集,位图,超级日志和具有半径查询的地理空间索引,Redis具有内置复制,Lua脚本,LRU驱逐,事物和不同级别的磁盘持久性,并通过Redis Sentinel提供高可用性,并通过Redis群集实现自动分区.</code><br><strong>Redis的特性</strong>  </p>
<ul>
<li>速度快  </li>
<li>持久化  </li>
<li>多种数据结构  </li>
<li>支持多种编辑语言  </li>
<li>功能丰富  </li>
<li>简单  </li>
<li>主从复制  </li>
<li>高可用,分布式<br><strong>Redis典型应用场景</strong>   </li>
<li>缓存(数据查询,短连接,新闻内容,商品内容等)(最多使用)</li>
<li>分布式集群架构中的session分离  </li>
<li>聊天室的在线好友列表  </li>
<li>任务队列(秒杀,抢购,12306等等)(先进先出)</li>
<li>应用排行榜(可以给每个元素设置一个打分,这样就可以排序)</li>
<li>网站访问统计  </li>
<li>数据过期处理(可以精确到毫秒)<br><strong>redis数据结构</strong></li>
<li><p>String<br>string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。<br>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。<br>string类型是Redis最基本的数据类型，一个键最大能存储512MB。</p>
<p> redis 127.0.0.1:6379&gt; SET name “runoob”<br> OK<br> redis 127.0.0.1:6379&gt; GET name<br> “runoob”</p>
</li>
</ul>
<ul>
<li><p>Hash<br>Redis hash 是一个键值(key=&gt;value)对集合。<br>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<p> redis&gt; HMSET myhash field1 “Hello” field2 “World”<br> “OK”<br> redis&gt; HGET myhash field1<br> “Hello”<br> redis&gt; HGET myhash field2<br> “World”</p>
</li>
</ul>
<ul>
<li><p>List<br>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<p> redis 127.0.0.1:6379&gt; lpush runoob redis<br> (integer) 1<br> redis 127.0.0.1:6379&gt; lpush runoob mongodb<br> (integer) 2<br> redis 127.0.0.1:6379&gt; lpush runoob rabitmq<br> (integer) 3<br> redis 127.0.0.1:6379&gt; lrange runoob 0 10<br> 1) “rabitmq”<br> 2) “mongodb”<br> 3) “redis”</p>
</li>
<li><p>Set<br>添加一个 string 元素到 key 对应的 set 集合中，成功返回1，如果元素已经在集合中返回 0，如果 key 对应的 set 不存在则返回错误。  </p>
</li>
</ul>
<pre><code>redis 127.0.0.1:6379&gt; sadd runoob redis
(integer) 1
redis 127.0.0.1:6379&gt; sadd runoob mongodb
(integer) 1
redis 127.0.0.1:6379&gt; sadd runoob rabitmq
(integer) 1
redis 127.0.0.1:6379&gt; sadd runoob rabitmq
(integer) 0
redis 127.0.0.1:6379&gt; smembers runoob
1) &quot;redis&quot;
2) &quot;rabitmq&quot;
3) &quot;mongodb&quot;
</code></pre><ul>
<li><p>zset<br>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。<br>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。<br>zset的成员是唯一的,但分数(score)却可以重复。</p>
<p> redis 127.0.0.1:6379&gt; zadd runoob 0 redis<br> (integer) 1<br> redis 127.0.0.1:6379&gt; zadd runoob 0 mongodb<br> (integer) 1<br> redis 127.0.0.1:6379&gt; zadd runoob 0 rabitmq<br> (integer) 1<br> redis 127.0.0.1:6379&gt; zadd runoob 0 rabitmq<br> (integer) 0<br> redis 127.0.0.1:6379&gt; &gt; ZRANGEBYSCORE runoob 0 1000<br> 1) “mongodb”<br> 2) “rabitmq”<br> 3) “redis”</p>
</li>
</ul>
<p><strong>Redis安装</strong><br>三种启动方式  </p>
<ol>
<li>最简启动<br><code>redis-server.exe</code><br>验证方法<br><code>ps -ef | grep redis</code><br><code>netstat -antpl | grep redis</code><br><code>redis-cli -h ip -p port ping</code>    </li>
<li>动态参数启动 redis<br><code>redis-server --port 8088</code>  </li>
<li>配置文件启动<br><code>redis-server configPath</code>  </li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/25/elasticsearch第二篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/25/elasticsearch第二篇/" itemprop="url">elasticsearch第二篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-25T11:10:25+08:00">
                2018-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h4><p><code>类似数据库中的表结构定义</code></p>
<ul>
<li><p>作用</p>
<ul>
<li>定义Index下的字段名(Field Name)  </li>
<li>定义字段的类型,比如数值型,字符串型,布尔型等  </li>
<li>定义倒排索引相关的配置,比如是否索引,记录  position等<br>得到一个索引的mapping  <code>GET /test_index/_mapping</code>  </li>
</ul>
</li>
<li><p>自定义Mapping  </p>
<ul>
<li>禁止直接修改<br> Mapping中的字段类型一旦设定后,禁止直接修改,因为Lucene实现的倒排索引生成后不允许修改,可以重新建立新的索引,然后做reindex操作</li>
<li>允许新增字段 <code>通过dynamic参数来控制字段的新增</code>  <ul>
<li>true(默认)允许自动新增字段  </li>
<li>false不允许自动新增字段,但是文档 可以正常写入,但无法对字段进行查询等操作  </li>
<li>strict文档不能写入,报错<br>-几个设置</li>
<li>copy_to<br><code>将该字段的值复制到目标字段,实现类似_all的作用,不会出现在_source中,只用来搜索</code></li>
<li>index<br><code>控制当前字段是否索引,默认为true,即记录索引,false不记录,即不可搜索</code>  </li>
<li>index_options用于控制倒排索引记录的内容,有如下4种配置:<ul>
<li>docs只记录doc id  </li>
<li>freqs记录doc id和term frequencies(词频)</li>
<li>positions记录doc id,term frequencies和term position</li>
<li>offsets记录doc id,term frequencies,term position和character offsets<br>text类型默认配置为positions,其他默认为docs<br>记录内容越多,占用空间越大</li>
</ul>
</li>
<li>null_value<br><code>当字段遇到null值时的处理策略,默认为null,即空值,此时es会忽略该值,可以通过设定该值设定字段的默认值</code></li>
</ul>
</li>
</ul>
</li>
<li>Dynamic Mapping<br><code>es是依靠JSON文档的字段来实现自动识别字段类型</code>  </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/25/elasticsearch第一篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/25/elasticsearch第一篇/" itemprop="url">elasticsearch第一篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-25T11:07:22+08:00">
                2018-04-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h4><p><strong>文档 Document</strong><br><code>用户存储在es中的数据类型</code></p>
<ul>
<li><p>数据类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">核心数据类型</span><br><span class="line">    1.字符型:text,keyword</span><br><span class="line">    2.数值型:long,integer,short,byte,float,half_float,scaled_float</span><br><span class="line">    3.布尔:boolean</span><br><span class="line">    4.日期:date</span><br><span class="line">    5.二进制:binary</span><br><span class="line">    6.范围类型:integer_range,float_range,long_range,double_range,date_range,date_range</span><br><span class="line">复杂数据类型</span><br><span class="line">    1.数组类型array</span><br><span class="line">    2.对象类型object</span><br><span class="line">    3.嵌套类型nested object</span><br><span class="line">地理位置数据类型 </span><br><span class="line">    1.geo_point</span><br><span class="line">    2.geo_shape</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注:每个文档有唯一的id标识  </span><br><span class="line">1).自行指定  </span><br><span class="line">2).es自动生成</span><br></pre></td></tr></table></figure>
</li>
<li><p>元数据<br><code>用于标注文档的相关信息</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1._index:文档所在的索引名  </span><br><span class="line">2._type:文档所在的类型名</span><br><span class="line">3._id:文档唯一id</span><br><span class="line">4._source:文档的原始Json数据,可以从这里获取每个字段的内容</span><br><span class="line">5._all:整合所有字段内容到该字段,默认禁止</span><br></pre></td></tr></table></figure>
</li>
<li><p>文档Document API</p>
<ul>
<li><p>创建文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1.指定id创建文档api如下:</span><br><span class="line">PUT /test_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;username&quot;:&quot;hh&quot;,</span><br><span class="line">    &quot;age&quot;:1</span><br><span class="line">&#125;</span><br><span class="line">2.不指定id创建文档api如下:</span><br><span class="line">POST /test_index/doc</span><br><span class="line">&#123;</span><br><span class="line">    &quot;username&quot;:&quot;hh&quot;,</span><br><span class="line">    &quot;age&quot;:1</span><br><span class="line">&#125;</span><br><span class="line">3.es允许一次创建多个文档,从而减少网络传输开销,提升写入速率</span><br><span class="line">POST _bulk</span><br><span class="line">&#123;</span><br><span class="line">    &quot;index&quot;:&#123;</span><br><span class="line">        &quot;_index&quot;:&quot;test_index&quot;,&quot;_type&quot;:&quot;doc&quot;,&quot;id&quot;:&quot;3&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;username&quot;:&quot;hh&quot;,&quot;age&quot;:10</span><br><span class="line">    &#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;delete&quot;:&#123;</span><br><span class="line">        &quot;_index&quot;:&quot;test_index&quot;,&quot;_type&quot;:&quot;doc&quot;,&quot;_id&quot;:&quot;3&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;update&quot;:&#123;</span><br><span class="line">        &quot;_id&quot;:&quot;3&quot;,&quot;_index&quot;:&quot;test_index&quot;,&quot;_type&quot;:&quot;doc&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;doc&quot;:&#123;</span><br><span class="line">        &quot;age&quot;:&quot;20&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1.指定要查询的文档id</span><br><span class="line">GET/test_index/doc/1</span><br><span class="line">2.搜索所有文档,用到_search,如下:</span><br><span class="line">GET /test_index/doc/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;term&quot;:&#123;</span><br><span class="line">            &quot;_id&quot;:&quot;1&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">2.es允许一次查询多个文档</span><br><span class="line">GET /_mget</span><br><span class="line">&#123;</span><br><span class="line">    &quot;docs&quot;:&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;_index&quot;:&quot;test_index&quot;,</span><br><span class="line">            &quot;type&quot;:&quot;doc&quot;,</span><br><span class="line">            &quot;_id&quot;:&quot;1&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;_index&quot;:&quot;test_index&quot;,</span><br><span class="line">            &quot;_type&quot;:&quot;doc&quot;,</span><br><span class="line">            &quot;_id&quot;:&quot;2&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新文档</p>
</li>
<li>删除文档</li>
</ul>
</li>
</ul>
<p><strong>索引 Index</strong><br><code>由具有相同字段的文档列表组成</code></p>
<ul>
<li>索引中存储具有相同结构的文档(Document)   <ul>
<li>每个索引都有自己的mapping定义,用于定义字段名和类型  </li>
</ul>
</li>
<li>一个集群可以有多个索引  <ul>
<li>nginx日志存储的时候可以按照日期每天生成一个索引来存储</li>
</ul>
</li>
<li>索引API<br><code>es有专门的Index API,用于创建,更新,删除索引配置等</code>  <ul>
<li>创建索引api  <code>PUT/test/index</code>  </li>
<li>查看现有索引  <code>GET _cat/indices</code>  </li>
<li>删除索引api  <code>DELETE/test_index</code>  </li>
</ul>
</li>
<li>倒排索引与分词<ul>
<li>正排索引<code>文档Id到文档内容,单词的关联关系</code></li>
<li>倒排索引<code>单词到文档Id的关联关系</code><ul>
<li>单词词典<code>是倒排索引的重要组成</code><ul>
<li>记录所有文档的单词,一般比较大</li>
<li>记录单词到倒排列表的关联信息</li>
</ul>
</li>
<li>倒排列表<code>记录了单词对应的文档集合,由倒排索引项组成</code><br>倒排索引项(Posting)主要包含以下信息:<ul>
<li>文档Id,用于获取原始信息</li>
<li>单词频率(TF,Term Frequency),记录该单词在该文档中的出现次数,用于后续相关性算分</li>
<li>位置(Position),记录单词在文档中的分词位置(多个),用于做词语搜索(Phrase Query)</li>
<li>偏移(Offset),记录单词在文档的开始和结束位置,用于做高亮显示</li>
</ul>
</li>
</ul>
</li>
<li>分词<code>是指将文本转换成一系列单词(term or token)的过程,也可以叫做文本分析,在es中里面称为Analysis</code><br><strong>节点 Node</strong><br><code>一个Elasticsearch的运行实例,是集群的构成单元</code><br><strong>集群 Cluster</strong><br><code>由一个或多个节点组成,对外提供服务</code>  <h4 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h4><code>是es中专门处理分词的组件,英文名为Analyzer</code></li>
</ul>
</li>
<li>组成部分:<ul>
<li>Character Filters  <code>针对原始文本进行处理,比如去除html特殊标记</code></li>
<li>Tokenizer  <code>将原始文本按照一定规则切分为单词</code></li>
<li>Token Filters  <code>针对tokenizer处理的单词再加工,比如转小写,删除或新增等处理</code></li>
</ul>
</li>
<li>预定义的分词器<br><code>es自带如下的分词器:</code>  <ul>
<li>Standard<ul>
<li>默认分词器</li>
<li>按词切分,支持多语言</li>
<li>小写处理</li>
</ul>
</li>
<li>Simple  <ul>
<li>按照非字母切分</li>
<li>小写处理</li>
</ul>
</li>
<li>Whitespace <ul>
<li>按照空格切分 </li>
</ul>
</li>
<li>Stop  <ul>
<li>Stop Word指语气助词等修饰性的词语,比如the,an,的,这等等</li>
<li>相比Simple多了Stop Word处理</li>
</ul>
</li>
<li>Keyword <ul>
<li>不分词,直接将输入作为一个单词输出 </li>
</ul>
</li>
<li>Pattern  <ul>
<li>通过正则表达式自定义分隔符</li>
<li>默认是\W+,即非字符的符号作为分隔符 </li>
</ul>
</li>
<li>Language  <ul>
<li>提供了30+常见语言的分词器  </li>
</ul>
</li>
</ul>
</li>
<li>中文分词<ul>
<li>中文分词指的是将一个汉字序列切分为一个一个单独的词,在英文中,单词之间是以空格作为自然分界符,汉语中词没有一个形式上的分界符</li>
<li>上下文不同,分词结果迥异,比如交叉歧义问题,比如下面两种分词都合理<ul>
<li>乒乓球拍/卖/完了</li>
<li>乒乓球/拍卖/完了</li>
</ul>
</li>
<li>常见分词系统<ul>
<li>IK<ul>
<li>实现中英文单词的切分,支持ik_smart,ik_maxword等模式</li>
<li>可自定义词库,支持热更新分词词典</li>
<li><a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik</a></li>
</ul>
</li>
<li>jieba  <ul>
<li>python中最流行的分词系统,支持分词和词性标注  </li>
<li>支持繁体分词,自定义词典,并行分词等  </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>自定义分词<br><code>当自带的分词无法满足需求时,可以自定义分词,通过自定义Character Filters,Tokenizer和Token Filter实现</code>  <ul>
<li>Character Filters <ul>
<li>自带的如下:  <ul>
<li>HTML Strip去除html标签和转换html实体</li>
<li>Mapping进行字符替换操作</li>
<li>Pattern Replace进行正则匹配替换</li>
</ul>
</li>
<li>会影响后续tokenizer解析的postion和offset信息</li>
</ul>
</li>
<li>Tokenizer<ul>
<li>自带的如下:<ul>
<li>standard按照单词进行分割</li>
<li>letter按照空格进行分割</li>
<li>whitespace按照空格进行分割  </li>
<li>UAX URL Email按照standard分割,但不会分割邮箱和url</li>
<li>NGram和Edge NGram连词分割</li>
<li>Path Hierarchy按照路径进行分割<h4 id="Analyze-API"><a href="#Analyze-API" class="headerlink" title="Analyze API"></a>Analyze API</h4><code>es提供了一个测试分析的api接口,方便验证分词效果,endpoint是_analyze</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>可以直接指定analyzer进行测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">    &quot;analyzer&quot;:&quot;standard&quot;,</span><br><span class="line">    &quot;text&quot;:&quot;hello world!&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以直接指定索引中的字段进行测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST test_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">    &quot;field&quot;:&quot;username&quot;,</span><br><span class="line">    &quot;text&quot;:&quot;hello world&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以自定义分词器进行测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">    &quot;tokenizer&quot;:&quot;standard&quot;,</span><br><span class="line">    &quot;filter&quot;:[&quot;lowercase&quot;],</span><br><span class="line">    &quot;text&quot;:&quot;Hello World!&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/24/Elastic-Stack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/24/Elastic-Stack/" itemprop="url">Elastic Stack概述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-24T20:04:32+08:00">
                2018-04-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Elastic-Stack概述"><a href="#Elastic-Stack概述" class="headerlink" title="Elastic Stack概述"></a>Elastic Stack概述</h3><ul>
<li>elasticsearch是数据存储,查询与分析</li>
<li>kibana是数据探索与可视化分析</li>
<li>Beats,Logstash是数据收集与处理<h4 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h4></li>
<li><p>安装elasticsearch<br>进入<a href="https://www.elastic.co/cn/" target="_blank" rel="noopener">elasticsearch官网</a>,下载对应自己电脑型号和版本的压缩包,解压,进入bin目录,执行elasticsearch,启动elasticsearch</p>
</li>
<li><p>elasticsearch配置说明<br>1).cluster.name集群名称,以此作为是否同一集群的判断条件<br>2).node.name节点名称,以此作为集群中不同节点的区分条件<br>3).network.host/http.port网络地址和端口,用于http和transport服务使用<br>4).path.data数据存储地址<br>5).path.log日志存储地址</p>
</li>
<li><p>elasticsearch本地启动集群的方式<br>1).bin/elasticsearch<br>2).bin/elasticsearch -Ehttp.port=8200 -Epath.data=node2</p>
</li>
</ul>
<ol start="3">
<li>bin/elasticsearch -Ehttp.port=7200 -Epath.data=node3</li>
</ol>
<ul>
<li><p>如何验证三个节点组成一个集群<br>在浏览器上输入<a href="http://127.0.0.1:7200/_cat/nodes" target="_blank" rel="noopener">http://127.0.0.1:7200/_cat/nodes</a>,<br>就会展示<br>127.0.0.1 27 58 8    mdi - ZSq9WKC<br>127.0.0.1 28 58 6    mdi - V8BTpaW<br>127.0.0.1 29 58 8    mdi * Z_C-ibU<br>如果出现就证明成功</p>
</li>
<li><p>如何判断哪个是主节点,哪个是从节点<br>在浏览器上输入<a href="http://127.0.0.1:7200/_cat/nodes?v" target="_blank" rel="noopener">http://127.0.0.1:7200/_cat/nodes?v</a><br>然后出来<br>ip        heap.percent ram.percent cpu load_1m load_5m load_15m node.role master name<br>127.0.0.1   28    42  13              mdi       -      ZSq9WKC<br>127.0.0.1   28    42  13              mdi       -      V8BTpaW<br>127.0.0.1   29    42  13              mdi       <em>      Z_C-ibU<br>注:</em>代表主节点</p>
</li>
<li><p>如何查看集群的状态消息<br>在浏览器上输入<br><a href="http://127.0.0.1:7200/_cluster/stats" target="_blank" rel="noopener">http://127.0.0.1:7200/_cluster/stats</a></p>
</li>
<li>常用术语<br>1).Document文档数据<br>2).Index索引<br>3).Type索引中的数据类型<br>4).Field字段,文档的属性<br>5).Query DSL查询语法<h4 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h4></li>
<li>下载kibana<br>进入<a href="https://www.elastic.co/cn/" target="_blank" rel="noopener">kibana官网</a>下载<br>进入kibana的bin目录下,执行kibana,就启动kibana了</li>
<li>kibana.yml关键配置说明<br>1).server.host/server.port访问kibana用的地址和端口<br>2).elasticsearch.url待访问elasticsearch的地址</li>
<li>kibana常用功能说明<br>1).Discover数据搜索查看<br>2).Visualize图表制作<br>3).Dashboard仪表盘制作<br>4).Timelion时序数据的高级可视化分析<br>5).DevTools开发者工具<br>6).Management配置<h4 id="beats"><a href="#beats" class="headerlink" title="beats"></a>beats</h4></li>
<li>轻量级的数据传送<br>1).Filebeat日志文件<br>2).Metricbeat 度量数据<br>3).Packetbeat 网络数据<br>4).Winlogbeat Windows数据<br>5).Heartbeat健康检查</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">fireworks</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fireworks</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
