<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="ghost">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="ghost">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ghost">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>ghost</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ghost</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/MYSQL和Oracle的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/MYSQL和Oracle的区别/" itemprop="url">MYSQL和Oracle的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-22T13:19:55+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>Oracle为商用数据库,行业中占据相当的地位:市场占比2012年为40%.开发,管理资源相当丰富,有自己的matalink(有什么问题,都可以在那里得到较快的解决),一般项目中至少有两个Oracle数据库:联机事务处理(OLTP)数据库,联机分析处理数据库(OLAP),通过配置实现这两个数据库的同步,Oracle在这两个方面非常出色.  </li>
<li>Oracle具有良好的兼容性,可移植性,可连接性,高生产率,结构严谨,高可用,高性能使Oracle RDBMS具有良好的开放性.  </li>
<li>MYSQL为非商用开源数据库,免费,简便易用,中小型项目使用绝对没有问题,据说facebook这样的大型网站也用MYSQL做数据库.  </li>
<li>MYSQL更多的是追求轻量,易用,以及早期的事物操作及复杂查询优化的缺失,在传统的数据库应用场景中,份额极少.  </li>
<li>MYSQL最大的特点就是自由选择存储引擎,每个表都是一个文件,都可以选择合适的存储引擎.常见的引擎有InnoDB,MyISAM,NDBCluster等,但由于这种开放插件式的存储引擎,比如要求数据库与引擎之间的松耦合关系,从而导致文件的一致性大大降低,在SQL执行优化方面,也就有着一些不可避免的瓶颈,在多表关联,子查询优化,统计函数等方面是软肋,而且只支持极简单的HINI.  </li>
</ul>
<h3 id="MYSQL数据库特点"><a href="#MYSQL数据库特点" class="headerlink" title="MYSQL数据库特点"></a>MYSQL数据库特点</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;MYSQL作为一种开放源码数据库,以其简单易用的特点广泛被广大用户采用.<br>&nbsp;&nbsp;&nbsp;&nbsp;MYSQL虽然是免费的,但同Oracle,Sysbase,Informix,Db2等商业数据库一样,具有数据库系统的通用性:  </p>
<ul>
<li>数据库管理系统.所谓的数据库就是一些结构化的数据的联合体,要提供对这些数据的存取,增加,修改,删除或更加复杂的数据抽取等操作,需要有一个支撑系统,这就是数据库管理系统(DBMS),MYSQL完全具有这方面的功能.  </li>
<li>关系型数据库管理系统.在数据库的发展历程中,曾出现过多种不同形式的数据库系统,但关系型数据库管理系统(DBMS)以其优越性而被广为采用,现在几种广泛使用的数据库全为关系型数据库,同样,MYSQL也是关系型数据库,支持标准的结构化查询语言.  </li>
<li>开放源码数据库.同商业性的数据库相比,这是MYSQL最大的特点.MYSQL的源码是公开的,这就意味着任何人,只要遵守GPL的规则都可以对MYSQL的源码使用,修改以符合自己特殊的要求.  </li>
<li>技术特点.MYSQL是C/S架构的服务器,服务器端是多线程的,为客户端提供了不同的程序接口和链接库,如C,C++,java,PHP,Tcl等,也提供了简单的管理工具,如mysql,mysqlmin等.  </li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;MYSQL的特性:  </p>
<ul>
<li>开发语言是C/C++,支持多种编译器,如gcc,cc,xlc,acc等.  </li>
<li>良好的内存管理机制,尤其是内存泄漏问题的管理,通过了Pueify的严格测试.  </li>
<li>支持多种平台,如AIX,Solaris,HP,FreeBSD,Windows等.  </li>
<li>提供多种形式的API,为我们开发工具的选择提供了便利.  </li>
<li>使用多线程的技术,可充分发挥系统的特点,避免在SMP系统中出现仅使用但CPU的现象.  </li>
<li>对磁盘表的管理采用Btree加密及索引的技术,为我们快速访问数据提供了可能.  </li>
<li>高性能的内存申请技术  </li>
<li>临时表采用在内存中以哈希表实现  </li>
<li>提供多种数据类型  </li>
<li>支持定长和变长的记录  </li>
<li>所有的列都有缺省值,为我们的某些’粗心’提供了方便  </li>
<li>灵活,安全的权限和密码系统,密码在传输中加密传输,允许主机端验证密码  </li>
<li>客户端可以通过TCP/IP,Unix套接字,命令管道(NT)连接到MYSQL数据库服务器  </li>
<li>对多种字符集的完全支持  </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/mysql/" itemprop="url">mysql</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-22T13:19:55+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h3 id="什么是数据库"><a href="#什么是数据库" class="headerlink" title="什么是数据库"></a>什么是数据库</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;数据库(Database)是按照数据结构来组织、存储和管理数据的仓库，简而言之就是存储数据的仓库。  </p>
<h3 id="数据库的分类"><a href="#数据库的分类" class="headerlink" title="数据库的分类"></a>数据库的分类</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;层次式数据库，网络式数据库，关系型数据库<br>&nbsp;&nbsp;&nbsp;&nbsp;数据库可以按照一定的数据结构存储管理大量的数据及数据与数据之间的关系，它本质上是一种信息管理系统。它本质上是一种信息管理系统，数据库根据存储采用的数据结构的不同可以分为许多种，其中常见的有层次式数据库，网络式数据库，关系型数据库，其中关系型数据库占据着市场的主流.  </p>
<h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;关系型数据库是建立在关系模型<br>  基础上的数据库.这种定义听起来十分抽象,这里只是简单的表述为利用表来存储数据,用表和表之间的关系保存数据之间的关系的数据库称为关系型数据库.(这个定义不太严谨,但是更好理解).  </p>
<pre><code>常见的关系型数据库: 
    SqlServer  
    Oracle  
    MySql  
    DB2  
    ...
</code></pre><h3 id="MySql数据库的安装与配置"><a href="#MySql数据库的安装与配置" class="headerlink" title="MySql数据库的安装与配置"></a>MySql数据库的安装与配置</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;mysql下载地址:<a href="https://www.mysql.com/downloads/" target="_blank" rel="noopener">https://www.mysql.com/downloads/</a>,安装和配置步骤详见mysql安装文档.<br>&nbsp;&nbsp;&nbsp;&nbsp;注意:mysql安装的路径不要有中文和空格<br>&nbsp;&nbsp;&nbsp;&nbsp;默认的端口3306不要修改,保持默认即可</p>
<h3 id="MySql相关命令"><a href="#MySql相关命令" class="headerlink" title="MySql相关命令"></a>MySql相关命令</h3><pre><code>登录mysql客户端命令:mysql -uroot -proot -h localhost;
    -u:后面的root是用户名,这里使用的是超级管理员root;
    -p:后面的root是密码,这里在安装MySql时就一句你个指定的密码;
    -h:后面给出的localhost是服务器主机名,它是可以省略的,例如 mysql -uroot -proot;
退出客户端命令:quit或exit;
扩展:通过命令启动、停止、删除服务（在C:\Windows\System32下以管理员运行cmd.exe）
    启动:net start 服务名称
    关闭:net stop 服务名称
    删除:sc delete 服务名称
    (如果服务名称中间有空格,就需要前后加引号)
如果C:\Users\hh\mysql
    &apos;mysql&apos;不是内部或外部命令,也不是可运行的程序或批处理文件
则表示没有配置mysql的bin目录到path环境变量中!!!
</code></pre><h3 id="MySql常见的概念"><a href="#MySql常见的概念" class="headerlink" title="MySql常见的概念"></a>MySql常见的概念</h3><pre><code>数据库服务器:安装的mysql软件就是mysql服务器.
数据库:是数据库表的集合,数据库服务器中可以创建多个数据库.
表:类似于一个excel表格,用于存储数据
表记录:即表中的一行数据
</code></pre><h1 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h1><h3 id="SQL概述"><a href="#SQL概述" class="headerlink" title="SQL概述"></a>SQL概述</h3><pre><code>SQL,指结构化查询语言,全程是Structured QueryLanguage
SQL是操作关系型数据库通用的语言
SQL是非过程性语言
SQL是一个标准,各大数据库厂商都根据该标准提供了实现.
数据库厂商为了增强数据库的功能,添加了一些非标准的SQL,称之为数据库的&quot;方言&quot;.
</code></pre><h1 id="利用sql语句来操作数据库"><a href="#利用sql语句来操作数据库" class="headerlink" title="利用sql语句来操作数据库"></a>利用sql语句来操作数据库</h1><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><pre><code>语法:
CREATE DATABASE [IF NOT EXISTS] db_name [CHARACTER SET charset_name][COLLATE collation_name]
其中charset_name是为数据库指定的默认字符集
Collate是为数据库指定的默认校对规则
(校对规则是字符集内用于比较字符的一套规则,可以控制select 查询时 where 条件大小写是否敏感的规则)
练习:
~创建一个名称为mydb1的数据库.
    create database mydb1;
~创建一个使用gbk字符集的mydb2数据库
    create database mydb2 character set gbk;
</code></pre><h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><pre><code>语法:
    显示所有数据库:
        SHOW DATABASES
    显示数据库创建语句:
        SHOW CREATE DATABASE db_name
练习:
    ~查看当前数据库服务器中的所有数据库
        SHOW DATABASES;
    ~查看前面创建的mydb2数据库的定义信息
        SHOW CREATEBASE mydb2;
</code></pre><h3 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;注意:数据库一旦创建成功,其名字无法修改! </p>
<pre><code>语法:
    ALTER DATABASE db_name [CHARCHTER SET charset_name][COLLATE collation_name]
练习:
~查看服务器中的数据库,并把mydb2库的字符集修改为utf8
    alter database mydb2 character set utf8;
</code></pre><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><pre><code>语法:DROP DATABASE [IF EXISTS] db_name
练习:
~删除前面创建的mydb2数据库
    DROP DATABASE mydb2;
</code></pre><h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><pre><code>语法:
    选择数据库:use db_name;
    查询当前选择的数据:select database();
    (没有退出数据库的命令,如果想退出当前数据库进入另一个数据,直接use 切换到另一个数据库就可以了)    
</code></pre><h1 id="利用sql语句来操作数据库表"><a href="#利用sql语句来操作数据库表" class="headerlink" title="利用sql语句来操作数据库表"></a>利用sql语句来操作数据库表</h1><h3 id="MySql中常见的数据类型"><a href="#MySql中常见的数据类型" class="headerlink" title="MySql中常见的数据类型"></a>MySql中常见的数据类型</h3><p>1.字符串类型</p>
<pre><code>char(n)定长字符串
n的最大值为255,表示存储255个字符
    例如:stuid char(10)
一般用于长度固定的字符串,比如手机号、身份证号，效率高
varchar(n)不定长字符串
n的最大值为65535个字节(5.0以后的版本)
例如:username varchar(50)
一般用于长度不固定的字符串,比如用户名、昵称等，节省空间
</code></pre><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><pre><code>TINYINT:占用1个字节,相对于java中的byte
SMALLINT:占用2个字节,相对于java中的short
INT:占用4个字节,相对于java中的int
BIGINT:占用8个字节,相对于java中的long
FLOAT:4字节单精度浮点类型,相对于java中的float
DOUBLE:8个字节双精度浮点类型,相对于java中的double
</code></pre><h3 id="大数据类型"><a href="#大数据类型" class="headerlink" title="大数据类型"></a>大数据类型</h3><pre><code>BLOB:
大二进制类型,可以存入二进制类型的数据,通过这个字段,可以将图片、音频、视频等数据以二进制的形式存入数据库。最大为4GB.
TEXT:
大文本,被声明为这种类型的字段,可以保存大量的字符数据,最大为4GB.
注意:text属于mysql的方言,在其他数据库中为clob类型
</code></pre><h3 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h3><pre><code>DATE:日期2015-11-05
TIME:时间格式&apos;HH:MM:SS&apos; 19:19:19
DATETIME:日期时间 2015-11-05 19:19:19 年份范围:
TIMESTAMP:时间戳 2015-11-05 19:19:19 年份范围:
</code></pre><h3 id="逻辑型"><a href="#逻辑型" class="headerlink" title="逻辑型"></a>逻辑型</h3><pre><code>BIT型字段只能取两个值:0或1.
</code></pre><h3 id="字段的约束"><a href="#字段的约束" class="headerlink" title="字段的约束"></a>字段的约束</h3><pre><code>主键约束:保证所约束列中的值必须唯一且不能为空.
    添加主键约束(创建表时):col_name datatype primary key
    或(表已存在):Alter table tabname add primary key(col_name)
    设置主键自动增长:col_name datatype primary key auto_increment
唯一约束:unique 保证所约束列的值必须唯一,即不能重复.
非空约束: not null 保证所约束列的值不能为空
外键约束
</code></pre><h3 id="新增表语法"><a href="#新增表语法" class="headerlink" title="新增表语法:"></a>新增表语法:</h3><pre><code>create table table_name(
    field1 datatype,
    field2 datatype,
    field3 datatype
)[character set 字符集][collate 校对规则];
field:指定列名   datatype:指定列类型
注意:创建表时,要根据需保存的数据创建相应的列,并根据数据的类型定义相应的列类型.
创建表时,一般不需要指定字符集编码和校对规则,和数据库保持一致即可.

练习:
~创建employee表,表中字段信息如下:
字段                 属性
id                    整型
name                字符型
gender                字符型
birthday            日期型
entry_date            日期型
job                    字符型
salary                小数型
resume                大文本型
</code></pre><p>建表语句1:</p>
<pre><code>create table employee(
    id int,
    name varchar(50),
    gender char(1),
    birthday date,
    entry_date date,
    job varchar(50),
    salary double,
    resume text
);
</code></pre><h3 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h3><p>语法:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查看表结构:<code>desc     tabName</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查看当前所有表:<code>show tables</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查看当前数据库表建表语句:<code>show create table tabName</code>  </p>
<h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><p>语法:<br>1.增加列:  </p>
<pre><code>table tabname add col_name datatype [default expr][add col_name datatype...]
练习:在上面员工表的基础上增加一个image列
alter table employee add image bolb;
</code></pre><p>2.修改列:  </p>
<pre><code>alter table tabname modify (col_name datatype     [default expr][,modify col_name datatype]...)
练习:修改job列,使其长度为60.
alter table employee modify job varchar(60);
</code></pre><p>3.删除列:</p>
<pre><code>alter table tabname drop [column] col_name; 
练习:删除gender列.
alter table employee drop gender;
</code></pre><p>4.修改表名:  </p>
<pre><code>alter table old_tabname rename to new_tabname
或
rename table new_tabname to old_tabname;
练习:表明改为user.
alter table employee rename to user;
或
rename table user to employee;     
</code></pre><p>5.修改列名称:</p>
<pre><code>alter table tabname change [column] old_col_name new_col_name datatype 
练习:修改列名称:
alter table employee change name username varchar(100);
</code></pre><p>6.修改列的顺序</p>
<pre><code>alter table tabname modify col_name1 datatype after col_name2;
练习:将image插入到id列的后面
alter table employee modify image blob after id;
</code></pre><p>7.修改表的字符集</p>
<pre><code>alter table tabname character set character_name;
练习:修改表的字符集为gbk
alter table employee character set gbk;
</code></pre><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法:drop table tabname;</span><br><span class="line">练习:~删除employee表</span><br><span class="line">drop table user;</span><br></pre></td></tr></table></figure>
<h1 id="利用sql语句来操作数据库表记录"><a href="#利用sql语句来操作数据库表记录" class="headerlink" title="利用sql语句来操作数据库表记录"></a>利用sql语句来操作数据库表记录</h1><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>语法:<code>insert into tabname[(column[,column...])] values (value[,value...])</code><br>注意:<br>&nbsp;&nbsp;&nbsp;&nbsp;插入的数据应与字段的数据类型相同<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如:name列对应的值为字符串,插入的数据类型也应该 是字符串类型!<br>&nbsp;&nbsp;&nbsp;&nbsp;数据的大小应在列的规定范围之内<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如:name列字符串长度为10,那么插入的数据长度不能超过10!<br>&nbsp;&nbsp;&nbsp;&nbsp;在values中列出的数据位置必须与被对应列的排列位置相对应<br>&nbsp;&nbsp;&nbsp;&nbsp;字符串和日期格式的数据要用单引号引起来<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如:’张飞’,’2017-6-1’<br>&nbsp;&nbsp;&nbsp;&nbsp;如果要插入所有字段可以省写列列表,直接按表中字段声明的顺序写值列表.<br>练习:<br>~向员工表中插入三条数据<br>&nbsp;&nbsp;&nbsp;&nbsp;注意:编码格式不同时,set name gbk;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into employee(id,name,gender,birthday,entry_date,job,salary,resume) values(null,&apos;刘备&apos;,&apos;男&apos;,&apos;1876-1-1&apos;,&apos;1923-3-4&apos;,&apos;CEO&apos;,10000,&apos;很牛!!!&apos;);</span><br><span class="line">insert into employee values(null,&apos;张飞&apos;,&apos;男&apos;,&apos;1832-4-3&apos;,&apos;1934-2-3&apos;,&apos;大数据工程师&apos;,23333,&apos;还行吧!&apos;);</span><br><span class="line">insert into employee values(null,&apos;小乔,&apos;女&apos;,&apos;&apos;643-2-1&apos;,&apos;1923-2-2&apos;,&apos;&apos;前端开发工程师);</span><br></pre></td></tr></table></figure></p>
<p>在mysql中插入中文数据,或查询中文数据时的乱码问题:<br>&nbsp;&nbsp;&nbsp;&nbsp;乱码问题:客户端发送的数据是gbk,而服务器使用的utf-8的编码来处理客户端发来的数据,两端使用的编码不一致导致乱码.<br>&nbsp;&nbsp;&nbsp;&nbsp;解决方法1:在客户端可以通过set names gbk;通知服务器使用指定码表来处理客户端发送的数据,这种方式只对当前cmd命令窗口有效,每次新开的窗口都要设置一次.<br>&nbsp;&nbsp;&nbsp;&nbsp;解决方法2:可以通过修改mysql安装目录下的my.ini文件(57行)中的配置,来指定服务器端使用的码表,这种方式一劳永逸(注意配置完成后需要重启服务器!!);<br>&nbsp;&nbsp;&nbsp;&nbsp;查询数据库中的编码:show variables like ‘char%’;</p>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>语法:<code>update tab_name set col_name1=erpr1[,col_name=expr2...][where where_definition]</code><br>&nbsp;&nbsp;&nbsp;&nbsp;update语法可以用新增值更新原有表行中的各列.<br>&nbsp;&nbsp;&nbsp;&nbsp;set子句指示要修改哪些列和要给予哪些值.<br>&nbsp;&nbsp;&nbsp;&nbsp;where子句指定应更新哪些行,如没有where子句,则更新所有的行.<br>练习:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~将所有员工薪水修改为3000元.</span><br><span class="line">  update employee set salary=3000;</span><br><span class="line">~将姓名为&apos;貂蝉&apos;的员工薪水修改为11000元.</span><br><span class="line">  update employee set salary=11000 where name=&apos;貂蝉&apos;;</span><br><span class="line">~将张飞的薪水在原有基础上增加1000元.</span><br><span class="line">  update employee set salary=salary+1000 where name=&apos;张飞&apos;;</span><br></pre></td></tr></table></figure></p>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>语法:<code>delete from tab_name[where where_definition]</code><br>&nbsp;&nbsp;&nbsp;&nbsp;where用来筛选要删除的记录,如果不使用where子句,将删除表中所有数据.<br>&nbsp;&nbsp;&nbsp;&nbsp;delete语句不能删除某一列的值.<br>&nbsp;&nbsp;&nbsp;&nbsp;drop delete语句仅删除记录,不删除表本身,如要删除表,使用drop table语句.<br>练习:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~删除表中名称为&apos;张飞&apos;的记录.</span><br><span class="line">  delete from employee where name=&apos;张飞&apos;;</span><br><span class="line">~删除表中所有的记录.</span><br><span class="line">	delete from employee;</span><br></pre></td></tr></table></figure></p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><h4 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h4><p>语法:<code>select [destinct] * | {column1,column2,column3..} from table_name;</code><br>&nbsp;&nbsp;&nbsp;&nbsp;select指定查询哪些列的数据.<br>&nbsp;&nbsp;&nbsp;&nbsp;column指定列名.<br>&nbsp;&nbsp;&nbsp;&nbsp;*号代表查询所有列.<br>&nbsp;&nbsp;&nbsp;&nbsp;from 指定查询哪张表.<br>&nbsp;&nbsp;&nbsp;&nbsp;distinct可选,指显示结果时,是否剔除重复数据.<br>练习:</p>
<p>~执行下面的sql语句,创建exam表并插入数据</p>
<pre><code>create table exam(
    id int primary key auto_increment,
    naem varchar(20) not null,
    chinese double,
    math double,
    english double
);
</code></pre><p>~查询表中所有学生的信息.<br>  <code>select * from exam;</code><br>~查询表中所有学生的姓名和对应的语文成绩.<br> <code>select name,chinese from exam;</code><br>~过滤表中语文成绩重复数据.<br>  <code>select distinct chinese from exam;</code><br>~在所有想和省分数上加10分特长分显示.<br>  <code>select name,chinese+10,math+10,english+10 from exam;</code><br> 或者<br>  <code>select name,chinese+10 as 语文,math+10 as 数学, english+10 英语 from exam;</code></p>
<p>  ###通过as关键字指定别名,as可以省略不写.<br>~统计每个学生的总分(ifnull(colname,0))<br>  <code>select name,chinese+math+english 总分 from exam;</code><br>  <code>select name,chinese+math+ifnull(english,0)总分 from exam;</code></p>
<h3 id="使用where子句的查询"><a href="#使用where子句的查询" class="headerlink" title="使用where子句的查询"></a>使用where子句的查询</h3><p>语法:<code>select *|列名 from tablename[where where_definition]</code></p>
<p>练习:</p>
<p>~查询姓名为关羽的学生成绩<br>  <code>select * from exam where name=&#39;关羽&#39;;</code><br>~查询英语成绩大于90分的同学<br>  <code>select * from exam where english&gt;90;</code><br>~查询总分大于230分的所有同学<br>  <code>select name,chinese+math+ifnull(english,0)总分 from exam where chinese+math+ifnull(english,0)&gt;230;</code></p>
<p>  ###在where子句中不能使用列别名!!!<br>~查询语文分数在80~100之间的同学.<br>  <code>select * from exam where chinese&gt;80 and chinese&lt;100;</code><br> 或<br>  <code>select * from exam where chinese between 80 and 100;</code><br>~查询数学分数为75,76,77的同学,再查询分数不在这个范围内的同学.<br>  <code>select * from exam where math=75 or math=76 or math=77;</code><br>  <code>select * from exam where !(math=75 or math=76 or math=77);</code><br>  <code>select 8 from exam where not(math=75 or math=76 or math=77);</code><br> 或者<br>  <code>select * from exam where math in(75,76,77);</code><br> <code>select * from exam where math not in(75,76,77);</code><br>~查询数学分&gt;70,语文分&gt;80的同学.<br>  <code>select * from exam where math&gt;70 and chinese&gt;80;</code><br>~查询所有姓张的学生成绩<br>  <code>select * from exam where name like &#39;张%&#39;;</code><br>  like:模糊查询<br>  百分号(%):匹配0个或者多个字符,下划线(_):匹配一个字符<br>  例子:<br>    ‘200%’:找出任何以200开头的值<br>    ‘%200%’:找出任何存在200的值<br>    ‘<em>00%’:找出任何第二个位置和第三个位置为0的值<br>    ‘2</em>%_%’:找出任何以2开头,并且长度至少为3的值.<br>    ‘%2’:找出任何以2结尾的值.<br>    ‘_2%3’:找出任何第二个位置为2,并且以3结尾的值<br>    ‘2___3’:找出任何以2开始,以3结束的5位数</p>
<h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><p>语法:<code>select column1,column2,column3.. from tablename order by column asc|desc</code><br>&nbsp;&nbsp;&nbsp;&nbsp; order by指定排序的列,排序的列即可是表中的列名,也可以是select语句后指定的列名.<br>&nbsp;&nbsp;&nbsp;&nbsp;Asc升序(默认),Desc降序<br>&nbsp;&nbsp;&nbsp;&nbsp;order by 子句位于select语句的结尾.</p>
<p>练习:</p>
<p>~对数学成绩排序后输出(默认是升序)<br>  <code>select math from exam order by math;</code><br>~对总分排序按从高到低的顺序输出<br>  <code>select name,chinese+math+ifnull(english,0)总分 from exam order by 总分 desc;</code><br>~对姓张的学生总分排序输出<br>  <code>select name,chinese+math+ifnull(english,0)总分 from exam where name like &#39;张%&#39; order by 总分;</code></p>
<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>语法:<br>1.求符合条件的记录中指定列的记录数<br><code>select count(列名)... from tabname[where where_definition]</code><br>2.求符合条件的记录中指定列的和值<br><code>select sum(列名)...from tablename[where where_difinition]</code><br>3.求符合条件的记录中指定列的平均值<br><code>select avg(列名)...from tablename[where where_difinition]</code><br>4.求符合条件的记录中指定列的最大值<br><code>select max(列名)...from tablename[where where_difinition]</code><br>5.求符合条件的记录中指定列的最小值<br><code>select min(列名)...from tablename[where where_difinition]</code><br>练习:</p>
<p>~统计一个班级共有多少学生?<br>  <code>select count(*) from exam;</code><br>~统计数学成绩大于75的学生有多少个?<br>  <code>select count(*) from exam where math&gt;75;</code><br>~统计总分大于230的人数有多少?<br>  <code>select count(*) from exam where chinese+math+ifnull(english,0)&gt;230;</code><br>~统计一个班级数学总成绩?<br>  <code>select sum(math)数学总成绩 from exam;</code><br>~统计一个班级语文,英语,数学三科成绩的总和<br>  <code>select sum(chinese)+sum(math)+sum(ifnull(english,0))总成绩 from exam;</code><br> 或<br> <code>select sum(chinese+math+ifnull(english,0))总成绩 from exam;</code><br>~ 统计一个班级英语成绩平均分<br>  <code>select  avg(english) from exam;</code><br>~求一个班级总分平均分?<br>  <code>select avg(chinese+math+ifnull(english,0)) from exam;</code><br>~求班级总分最高分和最低分<br>  <code>select max(chinese+math+ifnull(english,0)) from exam;</code><br>  <code>select min(chinese+math+ifnull(english,0)) from exam;</code></p>
<h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><p>语法:<br><code>select column1,column2,column3...from tablename group by column hving...</code><br>练习:<br>执行下面的SQL,创建orders表并插入数据</p>
<pre><code>create table orders(
id int,
product varchar(20),
price float
);
insert into orders(id,product,price)values(1,&apos;小米手机&apos;,900);
insert into orders(id,product,price)values(2,&apos;奥妙洗衣液&apos;,60);
insert into orders(id,product,price)values(3,&apos;乐视TV&apos;,90);
insert into orders values(4,&apos;联想键盘&apos;,80);
insert into orders values(5,&apos;奥妙洗衣液&apos;,60);
insert into orders values(6,&apos;小米手机&apos;,900);
</code></pre><p>~对订单表中商品归类后,显示每一类商品的总价</p>
<pre><code>select * from orders group by product;
select count(*) from orders group by product;
select sum(price) from orders group by product;
</code></pre><p>~查询购买了几类商品,并且每类总价大于100的商品<br><code>select product,sum(price) 总价 form orders group by product having sum(price)&gt;100</code><br>~查询单价小于100而总价大于100的商品的名称<br><code>select * from orders where price&lt;100 group by product having sum(price)&gt;100</code><br>where和having的区别?<br>&nbsp;&nbsp;&nbsp;&nbsp;where子句和having子句都可以进行过滤,但是使用场景有所不同:<br>&nbsp;&nbsp;&nbsp;&nbsp;where子句对分组之前的数据进行过滤,不能使用聚合函数和列别名<br>&nbsp;&nbsp;&nbsp;&nbsp;having子句对分组之后的数据进行过滤,可以使用聚合函数和别名<br>&nbsp;&nbsp;&nbsp;&nbsp;使用where子句的地方一般都可以用having替换,但是使用having的地方一般不能用where替代</p>
<h1 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;外键:唯一标识其他表中的一条记录,用来通知数据库两张表字段之间的对应关系,并让数据库帮我们维护这样关系的键就叫做外键.<br>&nbsp;&nbsp;&nbsp;&nbsp;外键作用:确保数据库数据的完整性和一致性.<br>添加    外键:例如:<code>foreign key(dept_id) references dept(id)</code><br>案例:</p>
<pre><code>create table dept(
id int primary key auto_increment,
name varchar(20)
);
insert into dept values(null,&apos;财务部&apos;);
insert into dept values(null,&apos;人事部&apos;);
insert into dept values(null,&apos;科技部&apos;);
insert into dept values(null,&apos;销售部&apos;);
create table emp(
id int primary key auto_increment,
name varchar(20),
dept_id int,
foreign key(dept_id) references dept(id)
);
</code></pre><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><p>案例:</p>
<pre><code>create table emp(
id int primary key auto_increment,
name varchar(20),
dept_id int
);
insert into emp values(null,&apos;张三&apos;,1);
insert into emp values(null,&apos;李四&apos;,2);
insert into emp values(null,&apos;老王&apos;,3);
insert into emp values(null,&apos;刘能&apos;,5);
</code></pre><p>1.需求1:查询出部门表和员工表,同时列出部门信息和员工信息.</p>
<p><code>select * from dept,emp;</code>(笛卡尔积查询)<br><code>select * from dept,emp where emp.dept_id=dept.id;</code><br>或者<br><code>select * from dept inner join emp on dept_id=dept.id;</code></p>
<p>2.需求2:查询出部门信息和部门所对应的员工信息,同时列出那些没有员工的部门<br><code>select * from dept left join emp on dept_id=dept.id;</code><br>3.需求3:查询出部门信息和部门所对应的员工信息,同时列出那些没有部门<br>的员工<br><code>select * from dept right join emp on dept_id=dept.id;</code><br>4.需求3:查询出部门信息和部门所对应的员工信息,同时列出那些没有部门<br>的员工和那些没有员工的部门</p>
<p><code>select * from dept full join emp on dept_id=dept.id;</code></p>
<p>#mysql不支持</p>
<h3 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;两张表相乘得出来的结果,如果左边有m条记录,右边有n调记录,则查询出来的结果就是m*n条,这些查询结果中包含大量错误的结果,通常不会使用这种查询.</p>
<ol>
<li>内连接查询:查询出左右表(dept)有且右边表(emp)也有的记录.<br><code>select * from dept inner join emp on dept_id=dept.id;</code><br>2.左外连接查询:在内连接查询的基础上,加上左边表有而右边表没有的记录<br><code>select * from dept left join emp on dept_id=dept.id;</code><br>3.右外连接查询:在内部连接查询的基础上,加上右边表有而左边表没有的记录.<br><code>select * from dept right join emp on dept_id=dept.id</code><br>4.全外连接查询:在内连接查询的基础上,加上左边表有而右边表没有的记录和右边表有而左边表没有的记录.<br><code>select * from dept full join emp on dept.id=dept_id;</code><br>#mysql不支持全外连接查询<br>使用union模拟全外连接查询:<br><code>select * from dept left join emp on dept.id=dept_id
union
select * from dept right join emp on dept.id=dept_id;</code></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/Md5加密算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/Md5加密算法/" itemprop="url">MD5加密算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-22T13:19:55+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p></p><h3 style="text-align:center">MD5加密算法及应用</h3><p></p>
<h2 id="MD5简介"><a href="#MD5简介" class="headerlink" title="MD5简介"></a>MD5简介</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;MD5即Message-Digest Algorithm(信息-摘要算法5),用于确保信息传输完整一致,是计算机广泛使用的杂凑算法之一(又译为<a href="https://baike.baidu.com/item/%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">摘要算法</a>和<a href="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">哈希算法</a>),主流编程语言普遍已有MD5实现,就爱那个数据运算为另一固定长度值,值杂凑算法的基础原理,MD5的前身有MD2和MD3和MD4.  </p>
<h2 id="MD5算法的特点"><a href="#MD5算法的特点" class="headerlink" title="MD5算法的特点"></a>MD5算法的特点</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;1.压缩性:任意长度的数据,算出的MD5值长度都是固定的.<br>&nbsp;&nbsp;&nbsp;&nbsp;2.容易计算:从元数据计算出MD5值很容易.<br>&nbsp;&nbsp;&nbsp;&nbsp;3.抗修改性:对原数据进行任何改动,哪怕只修改1个字节,所得到的MD5值都有很大区别.<br>&nbsp;&nbsp;&nbsp;&nbsp;4.强抗碰撞:已知原数据和MD5值,想找到一个具有相同MD5值的数据(即伪造数据)是非常困难的.<br>&nbsp;&nbsp;&nbsp;&nbsp; </p>
<h2 id="MD5的作用"><a href="#MD5的作用" class="headerlink" title="MD5的作用"></a>MD5的作用</h2><p>MD5的作用是让大容量信息在用<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D" target="_blank" rel="noopener">数字签名</a>软件私人<a href="https://baike.baidu.com/item/%E5%AF%86%E9%92%A5" target="_blank" rel="noopener">密钥</a>前被<br>“<a href="https://baike.baidu.com/item/%E5%8E%8B%E7%BC%A9/130325
01" target="_blank" rel="noopener">压缩</a>“成一种保密的格式(就是把一个任意长度的字节串变换成一定长的十六进制数字串).<br>&nbsp;&nbsp;&nbsp;&nbsp;创建一个类对MD5加密实现进行封装:</p>
<pre><code>import java.math.BigInteger;  
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
public class MD5Utils {
public static String md5(String plainText) {
    byte[] secretBytes = null;
    try {
        secretBytes = MessageDigest.getInstance(&quot;md5&quot;).digest(
                plainText.getBytes());
    } catch (NoSuchAlgorithmException e) {
        throw new RuntimeException(&quot;没有md5这个算法！&quot;);
    }
    String md5code = new BigInteger(1, secretBytes).toString(16);
    for (int i = 0; i &lt; 32 - md5code.length(); i++) {
        md5code = &quot;0&quot; + md5code;
    }
    return md5code;
}
}   
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;在LoginServlet中利用MD5加密对password进行加密 </p>
<pre><code>String password = MD5Utils.md5(request.getParameter(&quot;password&quot;));
</code></pre><p>附加图片:</p>
<p><img src="http://res.cloudinary.com/fireworks/image/upload/v1512874801/Md5%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8_f4nehv.png" width="80%" height="10%" alt="MD5加密算法的原理及应用"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/java面试题总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/java面试题总结/" itemprop="url">java面试题总结(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-22T13:19:55+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="ThreadLocal-线程变量副本"><a href="#ThreadLocal-线程变量副本" class="headerlink" title="ThreadLocal(线程变量副本)"></a>ThreadLocal(线程变量副本)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Synchronized实现内存共享,ThreadLocal为每个线程维护一个本地变量.<br>&nbsp;&nbsp;&nbsp;&nbsp;采用空间换时间,它用于线程间的数据隔离,为每一个使用该变量的线程提供一个副本,每个线程都可以独立的改变自己的副本,而不会和其他线程的副本冲突.<br>&nbsp;&nbsp;&nbsp;&nbsp;ThreadLocal类中维护一个Map,用于存储每一个线程的变量副本,Map中元素的键为线程对象,而值为对应线程的变量副本.<br>&nbsp;&nbsp;&nbsp;&nbsp;ThreadLocal在Spring中发挥着巨大的作用,在管理Request作用域中的Bean,事务管理,任务调度,AOP等模块都出现了它的身影.<br>&nbsp;&nbsp;&nbsp;&nbsp;Spring中绝大部分都可以声明成Singleton作用域,采用ThreadLocal进行封装,因此有状态的Bean就能够以Singleton方式在多线程中正常工作了.</p>
<h3 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;java虚拟机规范中将java运行时数据分为六种.<br>&nbsp;&nbsp;&nbsp;&nbsp;1.程序计数器:是一个数据结构,用于保存当前正常执行的程序的内存地址,java虚拟机的多线程就是通过线程轮流切换并分配时间来实现,为了线程切换后能恢复到正确的位置,每条线程都需要一个独立的程序计数器,互不影响,该区域为”线程私有”.<br>&nbsp;&nbsp;&nbsp;&nbsp;2.java虚拟机栈:线程私有的,与线程生命周期相同,用于存储局部变量表,操作栈,方法返回值,局部<br>变量表放着基本数据类型,还有对象的引用.<br>&nbsp;&nbsp;&nbsp;&nbsp;3.本地方法栈:跟虚拟机栈很像,不过它是为虚拟机使用到的Native方法服务.<br>&nbsp;&nbsp;&nbsp;&nbsp;4.java堆:所有线程共享的一块内存区域,对象实例几乎都在这分配内存.<br>&nbsp;&nbsp;&nbsp;&nbsp;5.方法区:各个线程共享的区域,存储虚拟机加载的类信息,常量,静态变量,编译后的代码.<br>&nbsp;&nbsp;&nbsp;&nbsp;6.运行时常量池:代表运行时每个class文件中的常量表,包括几种常量:编译时的数字常量,方法或者域的引用.</p>
<h3 id="java-GC是在什么时候-对什么东西-做了什么事情"><a href="#java-GC是在什么时候-对什么东西-做了什么事情" class="headerlink" title="java GC是在什么时候,对什么东西,做了什么事情?"></a>java GC是在什么时候,对什么东西,做了什么事情?</h3><h5 id="在什么时候"><a href="#在什么时候" class="headerlink" title="在什么时候:"></a>在什么时候:</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;1.在新生代有一个Eden区和两个survivor区,首先将对象放入Eden区,如果空间不足就向其中一个survivor区上放,如果仍然放不下就会引发一次发生在新生代的minor GC,将存活的对象放入另一个survivor区中,然后清空Eden和之前的那个survivor区的内存里去.<br>&nbsp;&nbsp;&nbsp;&nbsp;2.大对象以及长期存活的对象直接进入老年区.<br>&nbsp;&nbsp;&nbsp;&nbsp;3.当每次执行minor GC的时候应该对要晋升到老年代的对象进行分析,如果这些马上要到老年区的老年对象的大小超过了老年区的剩余大小,那么执行一次Full GCyiy以尽可能的获得老年区的空间.  </p>
<h5 id="对什么东西"><a href="#对什么东西" class="headerlink" title="对什么东西:"></a>对什么东西:</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;从GC Roots搜索不到,而且经过一次标记清理之后仍没有复活的对象.</p>
<h5 id="做什么"><a href="#做什么" class="headerlink" title="做什么:"></a>做什么:</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;新生代:复制清理;<br>&nbsp;&nbsp;&nbsp;&nbsp;老年代:标记-清理和标记-压缩算法;<br>&nbsp;&nbsp;&nbsp;&nbsp;永久代:存放java中的类和加在类的类加载器本身.</p>
<h6 id="GC-Roots都有哪些"><a href="#GC-Roots都有哪些" class="headerlink" title="GC Roots都有哪些:"></a>GC Roots都有哪些:</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;1.虚拟机栈中的引用的对象<br>&nbsp;&nbsp;&nbsp;&nbsp;2.方法区中静态属性引用的对象,常量引用的对象<br>&nbsp;&nbsp;&nbsp;&nbsp;3.本地方法栈中JNI(即一般说的Native方法)引用的对象.</p>
<h3 id="Synchronized与Lock"><a href="#Synchronized与Lock" class="headerlink" title="Synchronized与Lock"></a>Synchronized与Lock</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Synchrnized与Lock都是可重入锁,同一个线程再次进入同步代码的时候,可以使用自己已经获取到的锁.<br>&nbsp;&nbsp;&nbsp;&nbsp;Synchronized是悲观锁机制,独占锁.而Locks.ReentrantLock是每次不加锁而是假设没有冲突而去完成某项操作,如果因为冲突失败就重试,直到成功为止.<br><strong>ReentrantLock适用场景</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;1.每个线程在等待一个锁的控制权的这段时间需要中断.<br>&nbsp;&nbsp;&nbsp;&nbsp;2.需要分开处理一些wait-notify,ReentrantLock里面的Condition应用,能够控制notify哪个线程,锁可以绑定多个条件.<br>&nbsp;&nbsp;&nbsp;&nbsp;3.具有公平锁功能,每个到来的线程将排队等待.  </p>
<p>###String,StringBuffer与StringBuilder之间区别<br>&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer是线程安全的,每次操作字符串,String会生成一个新的对象,而StringBuffer不会,StringBUilder是非线程安全的.<br>&nbsp;&nbsp;&nbsp;&nbsp;三者在执行速度方面比较:StringBuilder&gt;StringBuffer&gt;String<br><strong>三者的总结</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;1.如果操作少量的数据用String<br>&nbsp;&nbsp;&nbsp;&nbsp;2.单线程操作字符串下操作大量数据用StringBuilder<br>&nbsp;&nbsp;&nbsp;&nbsp;3.多线程操作字符串缓冲流下操作大量数据用StringBuffer  </p>
<h3 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a>fail-fast</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;机制是java集合(Collection)中的一种错误机制,当多个线程对同一个集合的内容操作时,就会产生fail-fast事件<br>&nbsp;&nbsp;&nbsp;&nbsp;例如:当某个线程A通过iterator去遍历集合的过程中,当该集合的内容被其他线程所改变,那么线程A访问集合时,就会抛出ConcurrentModificationException异常,产生fail-fast事件  </p>
<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;如果两个操作之间具有happens-before关系,那么钱一个操作的结果就会对后面一个操作可见.<br>&nbsp;&nbsp;&nbsp;&nbsp;1.程序顺序规则:一个线程中的每一个操作,happens-before于该线程中的任意后续操作.<br>&nbsp;&nbsp;&nbsp;&nbsp;2.监视器锁规则:对一个监视器锁的解锁,happens-before于随后对这个监视器锁的加锁.<br>&nbsp;&nbsp;&nbsp;&nbsp;3:volatile变量规则:对一个volatile域的写,happens-before于任意后续对这个volatile域的读.<br>&nbsp;&nbsp;&nbsp;&nbsp;4.传递性:如果A happens-before B,且B happens-before C,那么A happens-before C.<br>&nbsp;&nbsp;&nbsp;&nbsp;5.线程启动规则:Thread对象的start()方法happens-before于此线程的每一个动作.  </p>
<h3 id="Volatile和Synchronized四个不同点"><a href="#Volatile和Synchronized四个不同点" class="headerlink" title="Volatile和Synchronized四个不同点:"></a>Volatile和Synchronized四个不同点:</h3><p>1.粒度不同,前者锁对象和类,后者针对变量<br>2.synchronized阻塞,volatile线程不阻塞<br>3.synchronized保证三大特性,volatile不保证原子性<br>4.synchronized编译器优化,volatile不优化<br><strong>多线程三大特性</strong><br>1.原子性:事务有原子性,即一个操作或多个操作要么执行的过中不被任何元素打断,要么不执行.<br>2.可见性:当多个线程共享同一个变量时,其中一个线程修改了这个变量,其他线程能够立即看到修改后的值.<br>3.有序性:线程按顺序执行,线程中有代码,即让代码按顺序执行,优化代码.<br><strong>volatile具备两种特性:</strong><br>1.保证此变量对所有线程的可见性,指一条线程修改了这个变量的值,新增对于其他线程来说是可见的,但并不是多线程安全的.<br>2.禁止指令重排序优化.<br>volatile如何保证内存可见性:<br>&nbsp;&nbsp;&nbsp;&nbsp;1.当写一个volatile变量时,JVM会把该线程对应的本地<br>内存中的共享变量刷新到主内存中.<br>&nbsp;&nbsp;&nbsp;&nbsp;2.当读一个volatile变量时,JVM会把该线程对应的本地内存置为无效,线程接下来将从主内存中读取共享变量.   </p>
<h3 id="同步-异步-阻塞-非阻塞"><a href="#同步-异步-阻塞-非阻塞" class="headerlink" title="同步 异步 阻塞 非阻塞"></a>同步 异步 阻塞 非阻塞</h3><p>同步:就是一个任务的完成需要依赖另外一个任务,只有等待被依赖的任务完成之后,依赖任务才能完成.<br>异步:不需要等待被依赖的任务完成,只是通知被依赖的任务要完成什么工作,只要自己任务我那成了就算完成,被依赖的任务是否弯沉会通知回来.(异步的特点就是通知)<br>阻塞:CPU停下来等一个慢的操作完成之后,才会接着完成其他的工作.<br>非阻塞:就是在这个慢的操作执行时,CPU去做其他工作,等这个慢的操作完成后,CPU才会接着完成后续的操作.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/java面试题一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/java面试题一/" itemprop="url">java面试题一</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-22T13:19:55+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-面向对象的特征有哪些方面"><a href="#1-面向对象的特征有哪些方面" class="headerlink" title="1.面向对象的特征有哪些方面?"></a>1.面向对象的特征有哪些方面?</h3><p><strong>面向对象的特征主要有以下几个方面:</strong><br><strong>&nbsp;&nbsp;&nbsp;&nbsp;封装:</strong>封装是指将对象的实现细节隐藏起来,然后通过一些公用方法来暴露该对象的功能.<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;继承:</strong>继承是面向对象实现软件复用的重要手段,当子类继承父类后,子类作为一种特殊的父类,将直接获得父类的属性和方法.<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;多态:</strong>多态指的是子类对象可以直接赋值给父类变量,但运行时依然表现出子类的行为特征,这意味着同一个类型的对象在执行同一个方法时,可能表现出多种行为特征.<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;注:</strong>抽象也是面向对象的重要部分,抽象就是忽略一个主题中与当前目标无关的那些方面,以便更充分的注意与当前目标有关的方面,抽象并不打算了解全部问题,而只是考虑部分问题.<br>&nbsp;&nbsp;&nbsp;&nbsp;虽然抽象是面向对象的重要部分,但它不是面向对象的特征之一,因为所有的编程语言都需要抽象,当开发者进行抽象时应该考虑哪些特征是软件系统所需要的,那么这些特征就应该使用程序记录并表现出来,因此,需要抽象哪些特征没有必要的规定,而是取决于软件系统的功能需求.  </p>
<h3 id="2-String是最基本的数据类型吗"><a href="#2-String是最基本的数据类型吗" class="headerlink" title="2.String是最基本的数据类型吗?"></a>2.String是最基本的数据类型吗?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;不是,java中基本数据类型只有8个:byte,short,int,long,float,double,char,boolean.除了基本类型,剩下的都是引用类型,java5以后引入的枚举类型也算一种比较特殊的引用类型.  </p>
<h3 id="3-float-f-3-4-是否正确"><a href="#3-float-f-3-4-是否正确" class="headerlink" title="3.float f = 3.4;是否正确?"></a>3.float f = 3.4;是否正确?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;不正确,3.4是双精度数,将双精度(double)赋值给浮点类型(float)属于下转型,会造成精度损失,因此需要强制类型转换float f = (float)3.4;或者写成float f = 3.4F;  </p>
<h3 id="4-int和Integer有什么区别"><a href="#4-int和Integer有什么区别" class="headerlink" title="4.int和Integer有什么区别?"></a>4.int和Integer有什么区别?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;答:java是一个近乎纯洁的面向对象编程语言,但是为了编程的方便,java为每个基本类型都引入了对应的包装类型,int的包装类就是Integer,从java5开始引入了自动装箱/拆箱机制,使得二者可以互相转换.<br><strong>面试代码题(一)</strong>  </p>
<pre><code>class AutoUnboxingTest{
  public static void main(String[] args){
    Integer a = new Integer(3);
    //将3自动封装成Integer类型
    Integer b = 3;
    int c = 3;
    //false 两个引用没有引用同一个对象
    System.out.print(a == b);
    //true a自动拆箱成int类型再和c比较
    System.out.print(a == c);
  }
}  
</code></pre><p><strong>面试代码题(二)</strong>  </p>
<pre><code>public class Test{
  public static void main(String[] args){
    Integer f1 = 100,f2 = 100,f3 = 150,f4 = 150;
    //true
    System.out.println(f1 == f2);
    //false 
    //Integer值的范围在-128 ~ 127之间,如果在这个范围内,不会new新的Integer对象,而是直接引用常量池中的Integer对象.
    System.out.printlm(f3 == f4);
  }
}
</code></pre><h3 id="5-amp-和-amp-amp-的区别"><a href="#5-amp-和-amp-amp-的区别" class="headerlink" title="5.&amp;和&amp;&amp;的区别?"></a>5.&amp;和&amp;&amp;的区别?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&amp;运算符有两种用法:(1)按位与;(2)逻辑与.&amp;&amp;运算符是短路与运算.逻辑与与短路与的差别非常巨大,虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true.&amp;&amp;之所以称为短路运算是因为,如果&amp;&amp;左边的表达式的值是false,右边的表达式会被直接短路掉,不会进行运算.<br>&nbsp;&nbsp;&nbsp;&nbsp;很多时候我们可能都需要用&amp;&amp;而不是&amp;,例如在验证用户登录时判定用户名不是null而且不是空字符串,应当写为:username != null &amp;&amp; !username.equals(“”),二者的顺序不能交换,更不能用&amp;运算符,因为第一个条件如果不成立,根本不能进行字符串的equals比较,否则会产生NullPointerException异常,注意:逻辑或运算符(|)和短路运算符(||)的差别也是如此.  </p>
<h3 id="6-解释内存中的栈-stack-堆-heap-和方法区-method-area-的用法"><a href="#6-解释内存中的栈-stack-堆-heap-和方法区-method-area-的用法" class="headerlink" title="6.解释内存中的栈(stack),堆(heap)和方法区(method area)的用法."></a>6.解释内存中的栈(stack),堆(heap)和方法区(method area)的用法.</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;通常我们定义了一个基本数据类型的变量,一个对象的引用,还有就是函数调用的现场保存都使用JVM中栈空间,而通过new关键字和构造器创建的对象则放在堆空间,堆是垃圾收集器管理的主要区域,由于现在的垃圾收集器都采用分代收集算法,所以堆空间还可以细分为新生代和老生代,再具体一点可以分为Eden,Survivor(又分为From Survivor和To Survivor),Tenured;方法区和堆都是各个线程共享的内存区域,用于存储已经被快JVM加载的类信息,常量,静态变量,JIT编译器编译后的代码等数据;程序中的字面量如直接书写的100,’hello’和常量都是放在常量池中,常量池也是方法区的一部分,栈空间操作起来最但是栈很小,栈空间用光了会引发StackOverflowError,而对和常量池空间不足则会引发OutOfMemoryError.<br><strong>例子:</strong><br><code>String str = new String(&quot;hello&quot;);</code><br>上面的语句变量str放在栈上,用new创建出来的字符串对象放在堆上,而”hello”这个字面量是放在方法区的. </p>
<h3 id="7-switch是否能作用在byte上-是否能作用在long上-是否能作用在String上"><a href="#7-switch是否能作用在byte上-是否能作用在long上-是否能作用在String上" class="headerlink" title="7.switch是否能作用在byte上,是否能作用在long上,是否能作用在String上?"></a>7.switch是否能作用在byte上,是否能作用在long上,是否能作用在String上?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在java5以前,switch(expr)中,expr只能在byte,short,char,int.从java5开始,java中引入了枚举类型,expr也可以是enum类型,从java7开始,expr还可以是字符串String,但是long类型在目前所有版本中都是不可以的.  </p>
<h3 id="8-Math-roud-11-5-等于多少-Math-round-11-5-等于多少"><a href="#8-Math-roud-11-5-等于多少-Math-round-11-5-等于多少" class="headerlink" title="8.Math.roud(11.5)等于多少?Math.round(-11.5)等于多少?"></a>8.Math.roud(11.5)等于多少?Math.round(-11.5)等于多少?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Math.round(11.5)的返回值是12,Math.round(-11.5)的返回值是-11,四舍五入的原理是在参数上加0.5然后进行下取整.  </p>
<h3 id="9-用最有效的方法计算2乘以8"><a href="#9-用最有效的方法计算2乘以8" class="headerlink" title="9.用最有效的方法计算2乘以8?"></a>9.用最有效的方法计算2乘以8?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;2&lt;&lt;3(左移3位相当于乘以2的3次方,右移3位相当于除以2的3次方).  </p>
<h3 id="10-数组中有没有length-方法-String有没有length-方法"><a href="#10-数组中有没有length-方法-String有没有length-方法" class="headerlink" title="10.数组中有没有length()方法,String有没有length()方法?"></a>10.数组中有没有length()方法,String有没有length()方法?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;数组中没有length()方法,有length的属性,String有length()方法.  </p>
<h3 id="11-构造器-constructor-是否被重写-override"><a href="#11-构造器-constructor-是否被重写-override" class="headerlink" title="11.构造器(constructor)是否被重写(override)?"></a>11.构造器(constructor)是否被重写(override)?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;构造器不能被继承,因此不能被重写,但可以被重载.  </p>
<h3 id="12-两个对象值相同-x-equals-y-true-但却可有不同的hash-code-这句话对不对"><a href="#12-两个对象值相同-x-equals-y-true-但却可有不同的hash-code-这句话对不对" class="headerlink" title="12.两个对象值相同(x.equals(y)==true),但却可有不同的hash code,这句话对不对?"></a>12.两个对象值相同(x.equals(y)==true),但却可有不同的hash code,这句话对不对?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;不对,如果两个对象满足x.equals(y)==true,它们的哈希吗(hash code)应当相同,java对于equals方法和hashCode方法是这样规定的:(1)如果两个对象相同(equals方法返回true),那么它们的hashCode值一定相同;(2)如果两个对象的hashCode相同,它们并不一定相同  </p>
<h3 id="13-是否可以继承String类"><a href="#13-是否可以继承String类" class="headerlink" title="13.是否可以继承String类?"></a>13.是否可以继承String类?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;String类是final类,不可以被继承.<br><strong>&nbsp;&nbsp;&nbsp;&nbsp;继承String本身就是一个错误,对String类型最好的重用方式是关联关系和依赖关系而不是继承关系</strong>  </p>
<h3 id="14-当一个对象被当作参数传递到哟个方法后-此方法可改变这个对象的属性-并可返回变化后的结果-那么这里到底是值传递还是引用传递"><a href="#14-当一个对象被当作参数传递到哟个方法后-此方法可改变这个对象的属性-并可返回变化后的结果-那么这里到底是值传递还是引用传递" class="headerlink" title="14.当一个对象被当作参数传递到哟个方法后,此方法可改变这个对象的属性,并可返回变化后的结果,那么这里到底是值传递还是引用传递?"></a>14.当一个对象被当作参数传递到哟个方法后,此方法可改变这个对象的属性,并可返回变化后的结果,那么这里到底是值传递还是引用传递?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;值传递,java语言的方法调用只支持参数的值传递,当一个对象实例作为一个参数被传递到方法中时,参数的值就是对该对象的引用,对象的属性可以在被调用过程中被改变,但对对象引用的改变是不会影响到调用者的.  </p>
<h3 id="15-String和StringBuilder-StringBuffer的区别"><a href="#15-String和StringBuilder-StringBuffer的区别" class="headerlink" title="15.String和StringBuilder,StringBuffer的区别?"></a>15.String和StringBuilder,StringBuffer的区别?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;String类是不可变类,即一旦一个String对象被创建以后,包含在这个对象中的字符串序列是不可改变的,直至这个对象被销毁.<br>&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer对象则代表一个字符序列可变的字符串,当一个StringBuffer被创建以后,通过StringBuffer提供的append(),insert(),reverse(),setCharAt(),setLength()等方法可以改变这个字符串对象的字符序列,一旦通过StringBuffer生成了最终想要的字符串,就可以调用它的toString()方法,将其转换为一个String对象.<br>&nbsp;&nbsp;&nbsp;&nbsp; StringBuilder类,它也代表字符串对象,实际上,StringBuilder和StringBuffer基本相似,两个类的构造器和方法也基本相同,不同的是,StringBuffer是线程安全的,而StringBuilder则没有实现线程安全功能,所以性能略高,因此在通常情况下,如果需要创建一个内容可变的字符串对象,则应该优先使用StringBuilder类.<br><strong>三者的总结</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer是线程安全的,每次操作字符串,String会生成一个新的对象,而StringBuffer不会,StringBUilder是非线程安全的.<br>&nbsp;&nbsp;&nbsp;&nbsp;三者在执行速度方面比较:StringBuilder&gt;StringBuffer&gt;String<br>&nbsp;&nbsp;&nbsp;&nbsp;1.如果操作少量的数据用String<br>&nbsp;&nbsp;&nbsp;&nbsp;2.单线程操作字符串下操作大量数据用StringBuilder.<br>&nbsp;&nbsp;&nbsp;&nbsp;3.多线程操作字符串缓冲流下操作大量数据用StringBuffer.<br><strong>面试题1</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;什么情况下用+运算符进行字符串连接比调用StringBuffer/StringBuilder对象的append方法连接字符串性能更高?   </p>
<pre><code>如果在编写代码的过程中大量使用+进行字符串评价还是会对性能造成比较大的影响，但是使用的个数在1000以下还是可以接受的，大于10000的话，执行时间将可能超过1s，会对性能产生较大影响。如果有大量需要进行字符串拼接的操作，最好还是使用StringBuffer或StringBuilder进行。
</code></pre><p><strong>面试题2</strong>  </p>
<pre><code>public class Main {
  public static void main(String[] args) {
    String s1 = &quot;Programming&quot;;
    String s2 = new String(&quot;Programming&quot;);
    String s3 = &quot;Program&quot;;
    String s4 = &quot;ming&quot;;
    String s5 = &quot;Program&quot; + &quot;ming&quot;;
    String s6 = s3 + s4;
    //false
    System.out.println(s1 == s2);
    //true
    System.out.println(s1 == s5);
    //false
    System.out.println(s1 == s6);
    //true
    System.out.println(s1 == s6.intern());
    //false
    System.out.println(s2 == s2.intern());
  }
}
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>补充:</strong>解答上面的面试题需要清楚两点:1.String对象的intern方法会得到字符串对象在常量池中对应的版本的引用(如果常量池中有一个字符串与String对象的equals结果是true),如果常量池中没有对应的字符串,则该字符串将被添加到常量池中,然后返回常量池中字符串的引用;2.字符串的+操作其本质是创建了StringBuilder对象进行append操作,然后及nag拼接后的StringBuilder对象用toString方法处理成String对象.</p>
<h3 id="16-重载-Overload-和重写-Override-的区别"><a href="#16-重载-Overload-和重写-Override-的区别" class="headerlink" title="16.重载(Overload)和重写(Override)的区别."></a>16.重载(Overload)和重写(Override)的区别.</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;方法的重载和重写都是实现多态的方式,区别在于前者实现的是编译的多态性,而后者实现的是运行时的多态性.<br>&nbsp;&nbsp;&nbsp;&nbsp;重载要求两同一不同:同一个类中方法名相同,参数列表不同(参数个数不同,类型不同,顺序不同),至于方法的其他部分,如方法返回值类型,修饰符等,与方法重载没有任何关系.<br>&nbsp;&nbsp;&nbsp;&nbsp;重写一般用于子类继承父类时,重写父类中的方法.<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>重写的规则:</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;1.重写方法的参数列表必须完全与被重写的方法相同.<br>&nbsp;&nbsp;&nbsp;&nbsp;2.重写方法的访问修饰符一定要大于被重写方法的访问修饰符(public&gt;protected&gt;default&gt;private)<br>&nbsp;&nbsp;&nbsp;&nbsp;3.重写方法所抛出的异常必须和被重写方法所抛出的异常一致,或者是其子类.<br>&nbsp;&nbsp;&nbsp;&nbsp;4.重写方法的返回值必须和被重写方法的返回值一致.<br>&nbsp;&nbsp;&nbsp;&nbsp;5.被重写方法不能为private,否则在其子类中只是定义了一个方法,并没有对其进行重写.<br>&nbsp;&nbsp;&nbsp;&nbsp;6.静态方法不能被重写为非静态方法.(会编译错误)<br><strong>面试题:</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;为什么不能根据返回类型来区分重载?  </p>
<pre><code>对于int f(){}和void f(){}两个方法,如果这样调用int result = f();,系统可以识别是调用返回值类型为int的方法,但是java调用方式时可以忽略方法返回值,如果采用如下方法来调用f();,你能判断是调用哪个方法吗?如果你尚且布恩那个判断,那么java系统也会糊涂,在编程过程中有一条重要规则:不能让系统糊涂,系统一糊涂,肯定就是你错了,因此,java里不能使用方法返回值类型作为区分方法重载的依据.  
</code></pre><h3 id="17-描述一下JVM加载class文件的原理机制"><a href="#17-描述一下JVM加载class文件的原理机制" class="headerlink" title="17.描述一下JVM加载class文件的原理机制"></a>17.描述一下JVM加载class文件的原理机制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;JVM中类的装载是由类加载器(ClassLoader)和它的子类来实现的,java中的类加载器是一个重要的java运行时系统组件,它负责在运行时查找和装入类文件中的类.<br>&nbsp;&nbsp;&nbsp;&nbsp;由于java的跨平台性,经过编译的java源程序并不是一个可执行程序,而是一个或多个类文件,当java程序需要使用某一个类时,JVM会确保这个类已经被加载,连接(验证,准备和解析)和初始化.类的加载是指把类的.class文件中的数据读入到内存中,通常是创建一个字节数组读入.class文件,然后产生与所加载类对应的class对象,加载完成后,class对象还不完整,所以此时的类还不可用,当类被加载后就进入连接阶段,这一阶段包括验证,准备(为静态变量分配内存并设置默认的初始值)和解析(将符号引用替换为直接引用)三个步骤,最后JVM对类进行初始化,包括:1).如果类存在直接的父类并且这个类还没有被初始化,那么就先初始化父类,2).如果类中存在初始化语句,就依次执行这些初始化语句.<br>&nbsp;&nbsp;&nbsp;&nbsp;类的加载是由类加载器完成后,类加载器包括:根加载器(Bootstrap),扩展加载器(Extension),系统加载器(System)和用户自定义加载器(java.lang.ClassLoader的子类).从java2(jdk1.2)开始,类加载器过程采取了父类委托机制(PDM).PDM更好的保证了java平台的安全性,类的加载首先请求父类加载器加载,父类加载器无能为力时才由其子类加载器自行加载.JVM不会向java程序提供Bootstrap的引用,下面是关于几个类加载器的说明:</p>
<ul>
<li>根加载器(Bootstrap):一般用本地代码实现,负责加载JVM基础核心类库(rt.jar);  </li>
<li>扩展加载器(Extension):从java.ext.dirs系统属性所指定的目录中加载类库,它的父加载器是Bootstrap;  </li>
<li><p>系统加载器(System):又叫应用类加载器,其父类是Extension,它是应用最广泛的类加载器,它从环境变量classpath或者系统属性java.class.path所指定的目录记载类,是用户自定义加载器的默认父加载器.  </p>
<h3 id="18-char型变量中能不能存贮一个中文汉字-为什么"><a href="#18-char型变量中能不能存贮一个中文汉字-为什么" class="headerlink" title="18.char型变量中能不能存贮一个中文汉字,为什么?"></a>18.char型变量中能不能存贮一个中文汉字,为什么?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;char类型可以存储一个中文汉字,因为java中使用的编码是Unicode(不选择任何特定的编码,直接使用字符在字符集中的编码,这是统一的唯一方法),一个char类型占用2个字节(16bit),所以放一个中文是没问题的.  </p>
<h3 id="19-抽象类-abstract-class-和接口-interface-有什么异同"><a href="#19-抽象类-abstract-class-和接口-interface-有什么异同" class="headerlink" title="19.抽象类(abstract class)和接口(interface)有什么异同?"></a>19.抽象类(abstract class)和接口(interface)有什么异同?</h3><p>接口和抽象类很像,它们都具有如下<strong>特征</strong>.  </p>
</li>
<li><p>接口和抽象类都不能被实例化,它们都位于继承树的顶端,用于被其他类实现和继承.  </p>
</li>
<li><p>接口和抽象类都可以包含抽象方法,实现接口或继承抽象类的普通子类都必须实现这些这些抽象方法.<br>但接口和抽象类之间的差别非常大,这种差别主要体现在二者设计目的上,下面具体分析二者的差别.<br>&nbsp;&nbsp;&nbsp;&nbsp;接口作为系统与外界交互的窗口,接口体现的是一种规范,对于接口的实现者而言,接口规定了实现者必须向外提供哪些服务(以方法的形式来提供);对于接口的调用者而言,接口规定了调用者可以调用哪些服务,以及如何调用这些服务(就是如何来调用方法),当在一个程序中使用接口时,接口是多个模块间的耦合标准;当在多个应用程序之间使用接口时,接口是多个程序之间的通信标准.<br>&nbsp;&nbsp;&nbsp;&nbsp;从某种程度上来看,接口类似于整个系统的”总纲”,它制定了系统各模块应该遵循的标准,因此一个系统中的接口不应该经常改变,一旦接口被改变,对整个系统甚至其他系统的影响将是辐射式的,导致系统中大部分类都需要改写.<br>&nbsp;&nbsp;&nbsp;&nbsp;抽象类则不一样,抽象类作为系统中多个子类的共同父类,它所体现的是一种模版式设计.抽象类作为多个子类的抽象父类,可以被当成系统实现过程中的中间产品,这个中间产品已经实现了系统的部分功能(那些已经提供实现的方法),但这个产品依然不能当成最终产品,必须有更进一步的完善,这种完善可能有几种不同方法.<br>&nbsp;&nbsp;&nbsp;&nbsp;除此之外,接口和抽象类在用法上也存在如下<strong>差别</strong>.  </p>
</li>
<li><p>接口里只能包含抽象方法和默认方法,不能为普通方法提供方法实现;抽象类则完全可以包含普通方法.  </p>
</li>
<li>接口里不能定义静态方法;抽象类里可以定义静态方法. </li>
<li>接口里只能定义公共静态常量,不能定义普通成员变量;抽象类里则既可以定义普通成员变量,也可以定义静态常量.  </li>
<li>接口里不包含构造器;抽象类里可以包含构造器,抽象类里的构造器并不是用于创建对象,而是让其子类调用这些构造器来完成属于抽象类的初始化操作.</li>
<li>接口里不能包含初始化块,但抽象类则完全可以包含初始化块.</li>
<li><p>一个类最多只能有一个直接父类,包括抽象类;但一个类可以直接实现多个接口,通过实现多个接口可以弥补java单继承的不足.</p>
<h3 id="20-java中会存在内存泄漏吗-请简单描述"><a href="#20-java中会存在内存泄漏吗-请简单描述" class="headerlink" title="20.java中会存在内存泄漏吗,请简单描述."></a>20.java中会存在内存泄漏吗,请简单描述.</h3><p>&nbsp;&nbsp;&nbsp;&nbsp; 理论上java因为垃圾回收机制(GC)不会存在内存泄漏问题(这也是java被广泛使用于服务器端编程的一个重要原因);然而渣实际开发中,可能会存在无用但可达的对象,这些对象不能被GC回收,因此也会导致内存泄漏的发生,例如Hibernate的Session(一级缓存)中的对象属于持久态,垃圾回收器是不会回收这些对象的,然而这些对象中坑呢存在无用的垃圾对象,如果不及时关闭(close)或清空(flush)一级缓存就可能内存泄漏.  </p>
<h3 id="21-抽象的方法是否可同时是静态的-是否可同时是本地方法-是否可同时被synchronized修饰"><a href="#21-抽象的方法是否可同时是静态的-是否可同时是本地方法-是否可同时被synchronized修饰" class="headerlink" title="21.抽象的方法是否可同时是静态的,是否可同时是本地方法,是否可同时被synchronized修饰?"></a>21.抽象的方法是否可同时是静态的,是否可同时是本地方法,是否可同时被synchronized修饰?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;都不能,抽象方法需要子类重写,而静态的方法无法被重写,因此二者是矛盾的,本地方法是由本地代码实现的方法,而抽象方法是没有实现的,也是矛盾的.synchronized和方法的实现细节有关,抽象方法不涉及实现细节,因此也是相互矛盾的.  </p>
<h3 id="22-阐述静态变量和实例变量的区别"><a href="#22-阐述静态变量和实例变量的区别" class="headerlink" title="22.阐述静态变量和实例变量的区别."></a>22.阐述静态变量和实例变量的区别.</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;静态变量是被static修饰符修饰的变量,也称为类变量,它属于类,不属于类的任何一个对象,一个类不管创建多少个对象,静态变量在内存中有且仅有一个拷贝;实例变量必须依存于某一实例,需要先创建对象然后通过对象才能够访问它,静态变量可以实现让多个对象共享内存.<br><strong>补充:</strong>在java开发中,上下文类和工具类中通常会有大量的静态成员.  </p>
<h3 id="23-是否可以从一个静态方法内部发出对非静态方法的调用"><a href="#23-是否可以从一个静态方法内部发出对非静态方法的调用" class="headerlink" title="23.是否可以从一个静态方法内部发出对非静态方法的调用?"></a>23.是否可以从一个静态方法内部发出对非静态方法的调用?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;不可以,静态方法只能访问静态成员,因为非静态方法的调用要先创建对象,在调用静态方法时可能对象不能够没有被初始化.  </p>
<h3 id="24-如何实现对象克隆"><a href="#24-如何实现对象克隆" class="headerlink" title="24.如何实现对象克隆?"></a>24.如何实现对象克隆?</h3><p>有两种方式:<br>&nbsp;&nbsp;&nbsp;&nbsp;1).实现Cloneable接口并重写Object类中的clone()方法;<br>&nbsp;&nbsp;&nbsp;&nbsp;实现Serializable接口,通过对象的序列化和反序列化实现克隆,可以实现真正的深度克隆.<br><strong>补充:</strong>基于序列化和反序列化实现的克隆不仅仅是深度克隆,更重要的是通过泛型限定,可以检查出要克隆的对象是否支持序列化,这项检查是编译器完成的,不是在运行时抛出异常,这种方案明显优于使用Object类的clone方法克隆对象,让问题在编译的时候暴露出来总是好过把问题留到运行时.  </p>
<h3 id="25-java-GC是在什么时候-对什么东西-做了什么事情"><a href="#25-java-GC是在什么时候-对什么东西-做了什么事情" class="headerlink" title="25.java GC是在什么时候,对什么东西,做了什么事情?"></a>25.java GC是在什么时候,对什么东西,做了什么事情?</h3><h5 id="在什么时候"><a href="#在什么时候" class="headerlink" title="在什么时候:"></a>在什么时候:</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;1.在新生代有一个Eden区和两个survivor区,首先将对象放入Eden区,如果空间不足就向其中一个survivor区上放,如果仍然放不下就会引发一次发生在新生代的minor GC,将存活的对象放入另一个survivor区中,然后清空Eden和之前的那个survivor区的内存里去.<br>&nbsp;&nbsp;&nbsp;&nbsp;2.大对象以及长期存活的对象直接进入老年区.<br>&nbsp;&nbsp;&nbsp;&nbsp;3.当每次执行minor GC的时候应该对要晋升到老年代的对象进行分析,如果这些马上要到老年区的老年对象的大小超过了老年区的剩余大小,那么执行一次Full GC以尽可能的获得老年区的空间.  </p>
<h5 id="对什么东西"><a href="#对什么东西" class="headerlink" title="对什么东西:"></a>对什么东西:</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;从GC Roots搜索不到,而且经过一次标记清理之后仍没有复活的对象.</p>
<h5 id="做什么"><a href="#做什么" class="headerlink" title="做什么:"></a>做什么:</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;新生代:复制清理;<br>&nbsp;&nbsp;&nbsp;&nbsp;老年代:标记-清理和标记-压缩算法;<br>&nbsp;&nbsp;&nbsp;&nbsp;永久代:存放java中的类和加在类的类加载器本身.</p>
<h6 id="GC-Roots都有哪些"><a href="#GC-Roots都有哪些" class="headerlink" title="GC Roots都有哪些:"></a>GC Roots都有哪些:</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;1.虚拟机栈中的引用的对象<br>&nbsp;&nbsp;&nbsp;&nbsp;2.方法区中静态属性引用的对象,常量引用的对象<br>&nbsp;&nbsp;&nbsp;&nbsp;3.本地方法栈中JNI(即一般说的Native方法)引用的对象.<br><strong>补充:</strong>垃圾回收机制有很多种,包括:分代复制垃圾回收,标记垃圾回收,增量垃圾回收等方式,标准的java进程既有栈又有堆,栈保存了原始型局部变量,堆保存了要创建的对象,java平台对堆内存回收和再利用的基本算法被称为标记和清除,但是java对其进行了改进,采用”分代式垃圾收集”.这种方法会跟java对象的生命周期堆内存划分为不同的区域,在垃圾收集过程中,可能会将对象移到不同区域:  </p>
</li>
<li><p>伊甸园(Eden):这是对象最初诞生的区域,并且对大多数对象来说,这里是它们唯一存在过的区域.  </p>
</li>
<li>幸存者乐园(Survivor):从伊甸园幸存下来的对象会被挪到这里.  </li>
<li><p>终身颐养园(Tenured):这是足够老的幸存对象的归宿,年轻代收集(Minor-GC)过程是不会触及这个地方的,当年轻代收集不能把对象放进终身颐养园时,就会触发一次完全收集(Major-GC),这里可能还会牵扯到压缩,以便为大对象腾出足够的空间.  </p>
<h3 id="26-String-s-new-String-“xyz”-创建了几个字符串对象"><a href="#26-String-s-new-String-“xyz”-创建了几个字符串对象" class="headerlink" title="26.String s = new String(“xyz”);创建了几个字符串对象?"></a>26.String s = new String(“xyz”);创建了几个字符串对象?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;两个对象,一个是静态区的”xyz”,一个是用new创建在堆上的对象.  </p>
<h3 id="27-接口是否可继承接口-抽象类是否可实现接口-抽象类是否可继承具体类"><a href="#27-接口是否可继承接口-抽象类是否可实现接口-抽象类是否可继承具体类" class="headerlink" title="27.接口是否可继承接口,?抽象类是否可实现接口?抽象类是否可继承具体类?"></a>27.接口是否可继承接口,?抽象类是否可实现接口?抽象类是否可继承具体类?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;接口可以继承接口,而且支持多重继承,抽象类可以实现接口,抽象类可继承具体类也可以继承抽象类.  </p>
<h3 id="28-匿名内部类是否可以继承其他类-是否可以实现接口"><a href="#28-匿名内部类是否可以继承其他类-是否可以实现接口" class="headerlink" title="28.匿名内部类是否可以继承其他类?是否可以实现接口?"></a>28.匿名内部类是否可以继承其他类?是否可以实现接口?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;可以继承其他类或实现其他接口,在Swing编程和Android开发中常用次方式来实现时间监听和回调.  </p>
<h3 id="29-内部类可以引用它的包含类-外部类-的成员吗-有没有限制"><a href="#29-内部类可以引用它的包含类-外部类-的成员吗-有没有限制" class="headerlink" title="29.内部类可以引用它的包含类(外部类)的成员吗?有没有限制?"></a>29.内部类可以引用它的包含类(外部类)的成员吗?有没有限制?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;一个内部类对象可以访问创建它的外部类对象的成员,包括私有成员.  </p>
<h3 id="30-java中的final关键字有哪些用法"><a href="#30-java中的final关键字有哪些用法" class="headerlink" title="30.java中的final关键字有哪些用法?"></a>30.java中的final关键字有哪些用法?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;1).修饰符:表示该类不能被继承;2).修饰方法:表示方法不能被重写;3).修饰变量:表示变量只能一次赋值以后值不能被修改(常量).  </p>
<h3 id="31-比较java和javascript"><a href="#31-比较java和javascript" class="headerlink" title="31.比较java和javascript."></a>31.比较java和javascript.</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>基于对象和面向对象:</strong>java是一种真正的面向对象的语言,即使是开发简单的程序,必须设计对象;javascript是种脚本语言,它可以用来制作与网络无关的,与用户交互作用的复杂软件,它是一种基于对象和事件驱动的编程语言,因而它本身提供了丰富的内部对象提供设计人员使用.<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>解释和编译:</strong>java的源代码在执行之前,必须经过编译,javascript是一种解释型变成语言,其源代码不需要经过编译,由浏览器解释执行.(目前的浏览器几乎都使用了JIT(即时编译)技术来提升javascript的运行效率).<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>强类型变量和类弱型变量:</strong>java采用强类型变量检查,即所有变量在编译之前必须作声明;javascript中变量是弱类型的,甚至在使用变量钱可以不作声明,javascript的解析器在运行时检查推断其数据类型.  </p>
<h3 id="32-什么时候用断言-assert"><a href="#32-什么时候用断言-assert" class="headerlink" title="32.什么时候用断言(assert)?"></a>32.什么时候用断言(assert)?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;断言在软件开发中是一种常用的调试方式,很多开发语言中都支持这种机制.一般来说,断言用于保证程序最基本,关键的正确性,断言检查通常在开发和测试时开启,为了保证程序的执行效率,在软件发布后断言检查通常是关闭的,断言是一个包含不二表达式的语句,在执行这个语句时假定该表达式为true,如果表达式为false,那么表达式的值为false,那么系统会报告一个AssertionError,断言的使用如下面的代码所示:<br><code>assert(a&gt;0);//throws an AssertionError if a &lt;= 0</code><br><strong>断言可以有两种方式:</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;1.assert Expression1;<br>&nbsp;&nbsp;&nbsp;&nbsp;2.assert Expression1:Expression2;<br>&nbsp;&nbsp;&nbsp;&nbsp;Expression1 应该总是产生一个布尔值.<br>&nbsp;&nbsp;&nbsp;&nbsp;Expression2可以是得出一个值的任意表达式;这个值用于生成显示更多调试信息的字符串消息.<br>&nbsp;&nbsp;&nbsp;&nbsp;要在运行时启用断言,可以在启动JVM时使用-enableassertions或者-ea标记,  要在运行时选择禁用断言,可以在启动JVM时使用-da或者-disableassertions标记.要在系统类中启用或禁用断言,可使用-esa或-dsa标记,还可以在包的基础上启用或者禁用断言.<br><strong>注意:</strong>断言不应该以任何方式改变程序的状态,简单的来说,如果希望在不满足某些条件时阻止代码的执行,就可以考虑用断言来阻止它.  </p>
<h3 id="33-Error和Exceeption有什么区别"><a href="#33-Error和Exceeption有什么区别" class="headerlink" title="33.Error和Exceeption有什么区别?"></a>33.Error和Exceeption有什么区别?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Error错误,一般是指与虚拟机相关的问题,如系统崩溃,虚拟机错误,动态连接失败等,这种错误无法恢复或不可能捕获,将导致应用程序中断,通常应用程序无法处理这些错误.<br>&nbsp;&nbsp;&nbsp;&nbsp;Exception表示需要捕捉或者需要需要程序进行处理的异常,是一种设计或实现问题,也就是说,它表示如果程序运行正常,从不会发生的情况.  </p>
<h3 id="34-当java程序执行try块-catch块时遇到了return或throw语句会怎么执行"><a href="#34-当java程序执行try块-catch块时遇到了return或throw语句会怎么执行" class="headerlink" title="34.当java程序执行try块,catch块时遇到了return或throw语句会怎么执行?"></a>34.当java程序执行try块,catch块时遇到了return或throw语句会怎么执行?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;当java程序执行try块,catch块时遇到return或throw语句,这两个语句都会导致该方法立即结束,但是系统执行这两个语句并不会结束该方法,而是去寻找该异常处理流程中是否包含finally块,如果没有finally块,程序立即执行return或throw语句,方法终止;如果有finally块,系统立即开始执行finally块–只有当finally块执行完成后,系统才会再次跳回来执行try块里的return或throw语句,如果finally块里也使用了return或throw等导致方法终止的语句,finally块已经终止了方法,系统将不会跳回去执行try块,catch块里的任何代码.<br><strong>注意:</strong>尽量避免在finally块里使用return或throw等导致方法终止的语句,否则可能出现一些很奇怪的情况.  </p>
<h3 id="35-java语言如何进行异常处理-关键字-throws-throw-try-catch-finally分别如何使用"><a href="#35-java语言如何进行异常处理-关键字-throws-throw-try-catch-finally分别如何使用" class="headerlink" title="35.java语言如何进行异常处理,关键字:throws,throw,try,catch,finally分别如何使用?"></a>35.java语言如何进行异常处理,关键字:throws,throw,try,catch,finally分别如何使用?</h3><p>答:java通过面向对象的方法进行异常处理,把各种不同的异常进行分类,并提供了良好的接口,在java中,每个异常都是一个对象,它是Throwable类或其他子类的实例,当一个方法出现异常后便抛出一个异常对象,该对象中包含有异常信息,调用这个对象的方法可以捕获到这个异常并可以对其进行处理.java的异常处理是通过5个关键字来实现的:try,catch,throw,throws和finally,一般情况下是用try来执行一段程序,如果系统会抛出一个异常对象,可以通过它的类型来捕获它,或通过总是执行代码块来处理;try用来指定一块预防所有异常的程序;catch子句紧跟在try块后面,用来指定你想要捕获的异常的类型;throw语句用来明确地抛出一个异常;throws用来声明一个方法肯呢个抛出的各种异常(当然声明异常时允许无病呻吟);finally为确保一段代买不敢发生什么异常状况都要被执行;try语句可以嵌套,每当遇到一个try语句,异常的结构就会被放入异常栈中,直到所有的try语句都完成,如果下一级语句的try语句没有对某种异常进行处理,异常栈就会执行出栈操作,直到遇到有处理这种异常的try语句或者最终将异常抛给JVM.  </p>
<h3 id="36-运行时异常与受检异常有何异同"><a href="#36-运行时异常与受检异常有何异同" class="headerlink" title="36.运行时异常与受检异常有何异同?"></a>36.运行时异常与受检异常有何异同?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;异常表示程序运行过程中可能出现的非正常状态,运行时异常表示虚拟机的通常操作中可能遇到的异常,是一种常见运行错误,只要程序设计的没有问题就不会发生,受检异常跟程序运行的上下文环境有关,即使程序设计无误,仍然可能因使用的问题而引发,java编译器要求方法必须声明抛出可能发生的受检异常,但是并不要求必须声明抛出未被捕获的运行时异常,异常和继承一样,是面向对象程序设计中经常被滥用的东西,在Effective java中对异常的使用给出了以下指导原则:  </p>
</li>
<li><p>不要将异常处理用于正常的控制流(设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常)  </p>
</li>
<li>对可以恢复的情况使用受检异常,对编译错误使用运行时异常  </li>
<li>避免不必要的使用受检异常(可以通过一些状态检测手段来避免异常的发生)  </li>
<li>优先使用标准的异常  </li>
<li>每个方法抛出的异常都要有文档  </li>
<li>保持异常的原子性  </li>
<li>不要在catch中忽略掉捕获到的异常  </li>
</ul>
<h3 id="37-列出一些你常见的运行时异常"><a href="#37-列出一些你常见的运行时异常" class="headerlink" title="37.列出一些你常见的运行时异常?"></a>37.列出一些你常见的运行时异常?</h3><ul>
<li>ArithmeticException(算术异常)  </li>
<li>ClassCastException(类转换异常)  </li>
<li>IllegalArgumentException(非法参数异常)  </li>
<li>IndexOutOfBoundsException(下标越界异常)  </li>
<li>NullpointerException(空指针异常)  </li>
<li>SecurityException(安全异常)  </li>
</ul>
<h3 id="38-阐述final-finally-finalize的区别"><a href="#38-阐述final-finally-finalize的区别" class="headerlink" title="38.阐述final,finally,finalize的区别?"></a>38.阐述final,finally,finalize的区别?</h3><ul>
<li>final:修饰符(关键字)有三种用法:如果一个类被声明final,<br>意味着它不能再派生出新的子类,即不能被继承,因此它和abstract是反义词.将变量声明为final,可以保证它们在使用中不被改变,被声明为final的变量必须在声明时给定初值,而在以后的引用中只能读取不可修改,被声明为final的方法也同样只能使用,不能在子类中被重写.  </li>
<li>finally:通常放在try… catch…的后面构造总是执行代码块,这就意味着程序无论正常执行还是发生异常,这里的代码只要JVM不关闭都能执行,可以将释放外部资源的代码写在finally块中.  </li>
<li>finalize:Object类中定义的方法,java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作,这个方法是由垃圾收集器在销毁对象时调用的,通过重写finalize()方法可以整理系统资源或者执行其他清理工作.  </li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/java面试题四/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/java面试题四/" itemprop="url">java面试题四</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-22T13:19:55+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-http和https的区别"><a href="#1-http和https的区别" class="headerlink" title="1.http和https的区别"></a>1.http和https的区别</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;超文本传输协议以http协议用于在web浏览器和网站服务器之间传递信息,http协议以明文方式发送内容,不提供任何方式的数据加密,如果攻击者截取了web浏览器和网站服务器之间的传输报文,就可以直接读取其中的信息,因此,HTTP协议不适合传输一些敏感信息,比如:信用卡号.密码等支付信息.<br>&nbsp;&nbsp;&nbsp;&nbsp;为了解决http协议的这一缺点,需要使用另一协议:安全套接字层超文本传输协议https,为了数据传输的安全,https在http的基础上加上了SSL协议,SSL依靠证书来验证服务器的身份,并为浏览器和服务器之间的通信加密.  </p>
<h3 id="2-ThreadLocal-线程变量副本"><a href="#2-ThreadLocal-线程变量副本" class="headerlink" title="2.ThreadLocal(线程变量副本)"></a>2.ThreadLocal(线程变量副本)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Synchronized实现内存共享,ThreadLocal为每个线程维护一个本地变量.<br>&nbsp;&nbsp;&nbsp;&nbsp;采用空间换时间,它用于线程间的数据隔离,为每一个使用该变量的线程提供一个副本,每个线程都可以独立的改变自己的副本,而不会和其他线程的副本冲突.<br>&nbsp;&nbsp;&nbsp;&nbsp;ThreadLocal类中维护一个Map,用于存储每一个线程的变量副本,Map中元素的键为线程对象,而值为对应线程的变量副本.<br>&nbsp;&nbsp;&nbsp;&nbsp;ThreadLocal在Spring中发挥着巨大的作用,在管理Request作用域中的Bean,事务管理,任务调度,AOP等模块都出现了它的身影.<br>&nbsp;&nbsp;&nbsp;&nbsp;Spring中绝大部分都可以声明成Singleton作用域,采用ThreadLocal进行封装,因此有状态的Bean就能够以Singleton方式在多线程中正常工作了.</p>
<h3 id="3-java内存模型"><a href="#3-java内存模型" class="headerlink" title="3.java内存模型"></a>3.java内存模型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;java虚拟机规范中将java运行时数据分为六种.<br>&nbsp;&nbsp;&nbsp;&nbsp;1.程序计数器:是一个数据结构,用于保存当前正常执行的程序的内存地址,java虚拟机的多线程就是通过线程轮流切换并分配时间来实现,为了线程切换后能恢复到正确的位置,每条线程都需要一个独立的程序计数器,互不影响,该区域为”线程私有”.<br>&nbsp;&nbsp;&nbsp;&nbsp;2.java虚拟机栈:线程私有的,与线程生命周期相同,用于存储局部变量表,操作栈,方法返回值,局部<br>变量表放着基本数据类型,还有对象的引用.<br>&nbsp;&nbsp;&nbsp;&nbsp;3.本地方法栈:跟虚拟机栈很像,不过它是为虚拟机使用到的Native方法服务.<br>&nbsp;&nbsp;&nbsp;&nbsp;4.java堆:所有线程共享的一块内存区域,对象实例几乎都在这分配内存.<br>&nbsp;&nbsp;&nbsp;&nbsp;5.方法区:各个线程共享的区域,存储虚拟机加载的类信息,常量,静态变量,编译后的代码.<br>&nbsp;&nbsp;&nbsp;&nbsp;6.运行时常量池:代表运行时每个class文件中的常量表,包括几种常量:编译时的数字常量,方法或者域的引用.</p>
<h3 id="4-java-GC是在什么时候-对什么东西-做了什么事情"><a href="#4-java-GC是在什么时候-对什么东西-做了什么事情" class="headerlink" title="4.java GC是在什么时候,对什么东西,做了什么事情?"></a>4.java GC是在什么时候,对什么东西,做了什么事情?</h3><h5 id="在什么时候"><a href="#在什么时候" class="headerlink" title="在什么时候:"></a>在什么时候:</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;1.在新生代有一个Eden区和两个survivor区,首先将对象放入Eden区,如果空间不足就向其中一个survivor区上放,如果仍然放不下就会引发一次发生在新生代的minor GC,将存活的对象放入另一个survivor区中,然后清空Eden和之前的那个survivor区的内存里去.<br>&nbsp;&nbsp;&nbsp;&nbsp;2.大对象以及长期存活的对象直接进入老年区.<br>&nbsp;&nbsp;&nbsp;&nbsp;3.当每次执行minor GC的时候应该对要晋升到老年代的对象进行分析,如果这些马上要到老年区的老年对象的大小超过了老年区的剩余大小,那么执行一次Full GCyiy以尽可能的获得老年区的空间.  </p>
<h5 id="对什么东西"><a href="#对什么东西" class="headerlink" title="对什么东西:"></a>对什么东西:</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;从GC Roots搜索不到,而且经过一次标记清理之后仍没有复活的对象.</p>
<h5 id="做什么"><a href="#做什么" class="headerlink" title="做什么:"></a>做什么:</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;新生代:复制清理;<br>&nbsp;&nbsp;&nbsp;&nbsp;老年代:标记-清理和标记-压缩算法;<br>&nbsp;&nbsp;&nbsp;&nbsp;永久代:存放java中的类和加在类的类加载器本身.</p>
<h6 id="GC-Roots都有哪些"><a href="#GC-Roots都有哪些" class="headerlink" title="GC Roots都有哪些:"></a>GC Roots都有哪些:</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;1.虚拟机栈中的引用的对象<br>&nbsp;&nbsp;&nbsp;&nbsp;2.方法区中静态属性引用的对象,常量引用的对象<br>&nbsp;&nbsp;&nbsp;&nbsp;3.本地方法栈中JNI(即一般说的Native方法)引用的对象.</p>
<h3 id="5-Synchronized与Lock"><a href="#5-Synchronized与Lock" class="headerlink" title="5.Synchronized与Lock"></a>5.Synchronized与Lock</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Synchrnized与Lock都是可重入锁,同一个线程再次进入同步代码的时候,可以使用自己已经获取到的锁.<br>&nbsp;&nbsp;&nbsp;&nbsp;Synchronized是悲观锁机制,独占锁.而Locks.ReentrantLock是每次不加锁而是假设没有冲突而去完成某项操作,如果因为冲突失败就重试,直到成功为止.<br><strong>ReentrantLock适用场景</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;1.每个线程在等待一个锁的控制权的这段时间需要中断.<br>&nbsp;&nbsp;&nbsp;&nbsp;2.需要分开处理一些wait-notify,ReentrantLock里面的Condition应用,能够控制notify哪个线程,锁可以绑定多个条件.<br>&nbsp;&nbsp;&nbsp;&nbsp;3.具有公平锁功能,每个到来的线程将排队等待.  </p>
<h3 id="6-String-StringBuffer与StringBuilder之间区别"><a href="#6-String-StringBuffer与StringBuilder之间区别" class="headerlink" title="6.String,StringBuffer与StringBuilder之间区别"></a>6.String,StringBuffer与StringBuilder之间区别</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer是线程安全的,每次操作字符串,String会生成一个新的对象,而StringBuffer不会,StringBUilder是非线程安全的.<br>&nbsp;&nbsp;&nbsp;&nbsp;三者在执行速度方面比较:StringBuilder&gt;StringBuffer&gt;String<br><strong>三者的总结</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;1.如果操作少量的数据用String<br>&nbsp;&nbsp;&nbsp;&nbsp;2.单线程操作字符串下操作大量数据用StringBuilder<br>&nbsp;&nbsp;&nbsp;&nbsp;3.多线程操作字符串缓冲流下操作大量数据用StringBuffer  </p>
<h3 id="7-fail-fast"><a href="#7-fail-fast" class="headerlink" title="7.fail-fast"></a>7.fail-fast</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;机制是java集合(Collection)中的一种错误机制,当多个线程对同一个集合的内容操作时,就会产生fail-fast事件<br>&nbsp;&nbsp;&nbsp;&nbsp;例如:当某个线程A通过iterator去遍历集合的过程中,当该集合的内容被其他线程所改变,那么线程A访问集合时,就会抛出ConcurrentModificationException异常,产生fail-fast事件  </p>
<h3 id="8-happens-before"><a href="#8-happens-before" class="headerlink" title="8.happens-before"></a>8.happens-before</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;如果两个操作之间具有happens-before关系,那么钱一个操作的结果就会对后面一个操作可见.<br>&nbsp;&nbsp;&nbsp;&nbsp;1.程序顺序规则:一个线程中的每一个操作,happens-before于该线程中的任意后续操作.<br>&nbsp;&nbsp;&nbsp;&nbsp;2.监视器锁规则:对一个监视器锁的解锁,happens-before于随后对这个监视器锁的加锁.<br>&nbsp;&nbsp;&nbsp;&nbsp;3:volatile变量规则:对一个volatile域的写,happens-before于任意后续对这个volatile域的读.<br>&nbsp;&nbsp;&nbsp;&nbsp;4.传递性:如果A happens-before B,且B happens-before C,那么A happens-before C.<br>&nbsp;&nbsp;&nbsp;&nbsp;5.线程启动规则:Thread对象的start()方法happens-before于此线程的每一个动作.  </p>
<h3 id="9-Volatile和Synchronized四个不同点"><a href="#9-Volatile和Synchronized四个不同点" class="headerlink" title="9.Volatile和Synchronized四个不同点:"></a>9.Volatile和Synchronized四个不同点:</h3><p>1.粒度不同,前者锁对象和类,后者针对变量<br>2.synchronized阻塞,volatile线程不阻塞<br>3.synchronized保证三大特性,volatile不保证原子性<br>4.synchronized编译器优化,volatile不优化<br><strong>多线程三大特性</strong><br>1.原子性:事务有原子性,即一个操作或多个操作要么执行的过中不被任何元素打断,要么不执行.<br>2.可见性:当多个线程共享同一个变量时,其中一个线程修改了这个变量,其他线程能够立即看到修改后的值.<br>3.有序性:线程按顺序执行,线程中有代码,即让代码按顺序执行,优化代码.<br><strong>volatile具备两种特性:</strong><br>1.保证此变量对所有线程的可见性,指一条线程修改了这个变量的值,新增对于其他线程来说是可见的,但并不是多线程安全的.<br>2.禁止指令重排序优化.<br>volatile如何保证内存可见性:<br>&nbsp;&nbsp;&nbsp;&nbsp;1.当写一个volatile变量时,JVM会把该线程对应的本地<br>内存中的共享变量刷新到主内存中.<br>&nbsp;&nbsp;&nbsp;&nbsp;2.当读一个volatile变量时,JVM会把该线程对应的本地内存置为无效,线程接下来将从主内存中读取共享变量.   </p>
<h3 id="10-同步-异步-阻塞-非阻塞"><a href="#10-同步-异步-阻塞-非阻塞" class="headerlink" title="10.同步 异步 阻塞 非阻塞"></a>10.同步 异步 阻塞 非阻塞</h3><p>同步:就是一个任务的完成需要依赖另外一个任务,只有等待被依赖的任务完成之后,依赖任务才能完成.<br>异步:不需要等待被依赖的任务完成,只是通知被依赖的任务要完成什么工作,只要自己任务我那成了就算完成,被依赖的任务是否弯沉会通知回来.(异步的特点就是通知)<br>阻塞:CPU停下来等一个慢的操作完成之后,才会接着完成其他的工作.<br>非阻塞:就是在这个慢的操作执行时,CPU去做其他工作,等这个慢的操作完成后,CPU才会接着完成后续的操作.  </p>
<h3 id="11-cookie与session的区别"><a href="#11-cookie与session的区别" class="headerlink" title="11.cookie与session的区别"></a>11.cookie与session的区别</h3><p>1.session在服务器端,cookie在客户端.<br>2.session默认被存放在服务器的一个文件中(不是内存)<br>3.session默认被默认依赖session_id,而session_id是存在cookie中的,也就是说,如果浏览器禁用了cookie,同时session也会失效(但是可以通过其他方式实现,比如在url中传递session_id)<br>4.session可以放在文件,数据库,或内存中都可以<br>5.用户验证这种场合一般会用session<br>因此,维持一个回话的核心就是客户端的唯一标识,即session_id  </p>
<h3 id="12-HttpClient"><a href="#12-HttpClient" class="headerlink" title="12.HttpClient"></a>12.HttpClient</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;HttpClient是Apache Jakarta Common下的子项目,用来提供高效的,最新的,功能丰富的支持HTTP协议的客户端编程工具包,并且它支持HTTP协议的最新版本和建议,HttpClient已经应用在很多的项目中.<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>特性:</strong>  </p>
<ul>
<li>基于标准,纯净的java语言,实现了Http1.0和Http1.1  </li>
<li>以可扩展的面向对象的结构实现了Http全部的方法(get,post,put,delete,head,option,trace)  </li>
<li>支持HTTPS协议  </li>
<li>通过Http代理建立透明的连接  </li>
<li>利用connect方法通过Http代理建立隧道的Https连接  </li>
<li>基本,摘要,NTLMv2,NTLM2会话,SNPNEGO/Kerberos认证方案  </li>
<li>插件式的自定义认证方案  </li>
<li>便携可靠的套接字工厂使它更容易使用第三方解决方案  </li>
<li>连接管理器支持多线程应用.支持设置最大连接数,同时支持设置每个主句的最大连接数,发现并关闭过期的连接  </li>
<li>自佛那个处理Set-Cookie中的Cookie  </li>
<li>插件式的自定哟Cookie策略  </li>
<li>请求的输出流程可以避免流程内容直接缓冲到socket服务器  </li>
<li>响应的输入流可以有效的从socket服务器读取相应的内容  </li>
<li>在http1.0和http1.1中利用KeepAlive保持持久连接 </li>
<li>直接获取服务器发送的响应代码和头文件  </li>
<li>设置连接超时的能力  </li>
<li>实验性的支持http1.1响应缓存  </li>
<li>源代码基于Apache许可证可免费获取  </li>
</ul>
<h3 id="java中如何遍历Map对象的4种方法"><a href="#java中如何遍历Map对象的4种方法" class="headerlink" title="java中如何遍历Map对象的4种方法"></a>java中如何遍历Map对象的4种方法</h3><ul>
<li><p>方法一:在for-each循环中使用entry来遍历  </p>
<p> Map&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;();<br> for(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet()){<br>   System.out.println(“key=”+entry.getKey()+”,value = “+entry.getValue());<br> }</p>
</li>
</ul>
<ul>
<li><p>方法二:在for-each循环中遍历keys或values  </p>
<p> Map&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;();<br> //遍历map中的键<br> for(Integer key:map.keySet()){<br>   System.out.println(“key=”+key);<br> }<br> //遍历map中的值<br> for(Integer value:map.values()){<br>   System.out.println(“value =”+value);<br> }</p>
</li>
<li><p>方法三:使用Iterator遍历 </p>
<p> Map&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;();<br> Iterator&lt;Map.Entry&lt;Integer,Integer&gt;&gt; entries = map.entrySet().iterator();<br> while(entries.hasNext()){<br>   Map.Entry&lt;Integer,Integer&gt; entry = entries.next();<br>   System.out.println(“key=”+entry.getKey()+”value = “+entry.getValue());<br> }</p>
</li>
<li><p>方法四:不使用泛型  </p>
<p> Map map = new HashMap();<br> Iterator entries = map.entrySet().iterator();<br> while(entries.hasNext()){<br>   Map.Entry entry = (Map.Entry)entries.next();<br>   Integer key = (Integer)entry.getKey();<br>   Integer value = (Integer)entry.getValue();<br>   System.out.println(“key = “+key+”,value = “+value);<br> }</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/java面试题三/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/java面试题三/" itemprop="url">java面试题三</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-22T13:19:55+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">饿汉式:</span><br><span class="line">public class SingletonDemo&#123;</span><br><span class="line">	//创建一个静态类对象    </span><br><span class="line">	private static SingletonDemo instance = new SingletonDemo(); </span><br><span class="line">	//修饰符限定为private,避免了类在外部被实例化   </span><br><span class="line">    private SingletonDemo()&#123;</span><br><span class="line">	&#125;  </span><br><span class="line">	private static SingletonDemo getInstance()&#123;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">懒汉式:</span><br><span class="line">public class SingletonDemo&#123;  </span><br><span class="line">	private static SingletonDemo instance = null;  </span><br><span class="line">	private SingletonDemo()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	public static synchronized SingletonDemo getInstance()&#123;</span><br><span class="line">		if(instance == null)&#123;</span><br><span class="line">			instance = new SingletonDemo();</span><br><span class="line">		&#125;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/java面试题二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/java面试题二/" itemprop="url">java面试题二</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-22T13:19:55+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-List-Set-Map是否继承自Collection接口"><a href="#1-List-Set-Map是否继承自Collection接口" class="headerlink" title="1.List,Set,Map是否继承自Collection接口?"></a>1.List,Set,Map是否继承自Collection接口?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;List,Set是,Map不是,Map是键值对映射容器,与List和Set有明显的区别,而Set存储的零散的元素且不允许有重复元素(数学中的集合也是如此),List是线性结构的容器,2.适用于按数值索引访问元素的情形.  </p>
<h3 id="2-阐述ArrayList-Vector-LinkedList的存储性能和特性"><a href="#2-阐述ArrayList-Vector-LinkedList的存储性能和特性" class="headerlink" title="2.阐述ArrayList,Vector,LinkedList的存储性能和特性."></a>2.阐述ArrayList,Vector,LinkedList的存储性能和特性.</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList和Vector都是使用数组方式存储数据,此数组元素数大于实际存储的数据以便增加和插入元素,它们都允许直接按序号索引元素,但是插入元素要涉及数组元素移动等内存操作,所以索引数据快而插入数据慢,Vector中的方法由于添加了synchronized修饰,因此Vector是线程安全的容器,但性能上较ArrayList差,因此已经是java中的遗留容器.<br>&nbsp;&nbsp;&nbsp;&nbsp;LinkedList使用双向链表实现存储(将内存中零散的内存单元通过附加的引用关联起来,形成一个可以按序号索引的线性结构,这种链式存储方式与数组的连续存储方式相比,内存的利用率更高),按序号索引数据需要进行前向或后向遍历,但是插入数据时只需要记录本项的前后项即可,所有插入速度快.Vector属于遗留问题(java早期的版本中提供的容器,除此之外,Hashtable,Dictionary,BitSet,Stack,Properties都是遗留容器),已经不推荐使用,但是由于ArrayList和LinkedList都是非线程安全的,如果遇到多个线程操作同一个容器的场景,则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用.  </p>
<h3 id="3-Collection和Collections的区别"><a href="#3-Collection和Collections的区别" class="headerlink" title="3.Collection和Collections的区别?"></a>3.Collection和Collections的区别?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Collection是一个接口,它是Set,List等容器的父接口;Collections是一个工具类,提供了一系列的静态方法来辅助容器操作,这些方法包括对容器的搜索,排序,线程安全化等等.  &nbsp;&nbsp;&nbsp;&nbsp;</p>
<h3 id="4-List-Map-Set三个接口存储元素时-各有什么特点"><a href="#4-List-Map-Set三个接口存储元素时-各有什么特点" class="headerlink" title="4.List,Map,Set三个接口存储元素时,各有什么特点?"></a>4.List,Map,Set三个接口存储元素时,各有什么特点?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>List:</strong>元素有放入顺序,元素可重复,可以根据元素的索引来访问;<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>Map:</strong>元素按键值对存储,无放入顺序,可以根据每项元素的key来访问其value;<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>Set:</strong>元素无放入顺序,元素不可重复(注意:元素虽然无放入顺序,但是元素在Set中的位置是由元素的HashCode决定的,位置其实是固定的;用对象的equals()方法来区分元素是否重复),只能根据元素本身来访问(这也是set集合不允许重复的原因).  </p>
<h3 id="5-Thread类的sleep-方法和yield-方法的区别如下"><a href="#5-Thread类的sleep-方法和yield-方法的区别如下" class="headerlink" title="5.Thread类的sleep()方法和yield()方法的区别如下."></a>5.Thread类的sleep()方法和yield()方法的区别如下.</h3><ul>
<li>sleep()方法暂停当前线程后,会给其他线程执行机会,不会理会其他线程的优先级;但是yield()方法只会给优先级相同,或优先级更高的线程执行机会.  </li>
<li>sleep()方法会将线程转入阻塞状态,直到经过阻塞时间才会转入就绪状态;而yield()方法不会将线程转入阻塞状态,它只是强调当前线程进入就绪状态,因此完全有可能某个线程调用yield()方法暂停之后,立即再次获得处理器资源被执行.  </li>
<li>sleep()方法声明抛出了InterruptedException异常,所以调用sleep()方法时要么捕捉该异常,要么显示声明抛出该异常;而yield()方法则没有声明抛出任何异常.  </li>
<li>sleep()方法比yield()方法有更好的可移植性,通常不建议使用yield()方法来控制并发线程的执行</li>
</ul>
<h3 id="6-HashSet具有什么特点"><a href="#6-HashSet具有什么特点" class="headerlink" title="6.HashSet具有什么特点?"></a>6.HashSet具有什么特点?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;1.不能保证元素的排列顺序,顺序可能与添加顺序不同,顺序也有可能发生改变.<br>&nbsp;&nbsp;&nbsp;&nbsp;2.HashSet不是同步的,如果多个线程同时访问一个HashSet,假设有两个或者两个以上线程同时修改了HashSet集合时,则必须通过代码来保证其同步.<br>&nbsp;&nbsp;&nbsp;&nbsp;3.集合元素值可以是null.  </p>
<h3 id="7-简述并发性和并行性"><a href="#7-简述并发性和并行性" class="headerlink" title="7.简述并发性和并行性?"></a>7.简述并发性和并行性?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;并发性和并行性是两个概念,并行指在同一个时刻,有多条指令在多个处理器上同时执行; 并行性指在同一时刻只能有一条指令执行,但多个进程指令被快速轮换执行,使得在宏观上具有多个进程同时执行的效果.  </p>
<h3 id="8-进程和线程的区别"><a href="#8-进程和线程的区别" class="headerlink" title="8.进程和线程的区别?"></a>8.进程和线程的区别?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;进程和线程的主要差别在于它们是不同的操作系统资源管理方式.进程有独立的地址空间,一个进程崩溃后,在保护模式下不会对其他进程产生影响,而线程只是一个进程中的不同执行路径,线程有自己的堆栈和局部变量,但线程之间没有单独的地址空间,一个线程死掉就等于整个进程死掉,所以多进程的程序要比多线程的程序健壮,但在进程切换时,好肥资源较大,效率较差一些,但对于一些要求同时进行并且又要共享某些变量的并发操作,只能影片能够线程,不能用进程.<br>&nbsp;&nbsp;&nbsp;&nbsp;1.简而言之,一个程序至少有一个进程,一个进程至少有一个线程.<br>&nbsp;&nbsp;&nbsp;&nbsp;2.线程的划分尺度小于进程,使得多线程程序的并发性高.<br>&nbsp;&nbsp;&nbsp;&nbsp;3.另外,进程在执行过程中拥有独立的内存单元,而多个线程共享内存,从而极大地提高了程序的运行效率.<br>&nbsp;&nbsp;&nbsp;&nbsp;4.线程在执行过程中与进程还是有区别额.每个独立的线程有一个程序运行的入口,顺序执行序列和程序的出口,但是线程不能够独立运行,必须依存在应用程序中,由应用程序提供多个线程执行控制.<br>&nbsp;&nbsp;&nbsp;&nbsp;5.从逻辑角度来看,多线程的意义在于一个应用程序中,有多个执部分可以同时执行,但操作系统并没有将多个侠女横看作多个独立的应用,来实现进程的调度和管理以及资源分配,这就是进程和线程的重要区别.  </p>
<h3 id="9-创建线程的三种方式对比"><a href="#9-创建线程的三种方式对比" class="headerlink" title="9.创建线程的三种方式对比"></a>9.创建线程的三种方式对比</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;通过继承Thread类或实现Runnable,callable接口都可以实现多线程,不过实现Runnable接口与实现Callable接口的方式基本相同,只是Callable接口里定义的方法有返回值,可以声明抛出异常而已,因此可以将实现Runnable接口和实现Callable接口归为一种方式.这种方式与继承Thread方式之间的主要差别如下:<br>&nbsp;&nbsp;&nbsp;&nbsp;采用实现Runnable,Callable接口的方式创建多线程的优缺点:  </p>
<ul>
<li>线程类只是实现了Runnable接口或Callable接口,还可以继承其他类.  </li>
<li>在这种方式下,多个线程可以共享同一个target对象,所以非常适合多个相同线程来处理同一份资源的情况,从而可以将CPU,代码和数据分开,形成清晰的模型,较好额体现了面向对象的思路.  </li>
<li>劣势是,编程稍稍复杂,如果需要访问当前线程,则必须使用Thread.currentThread()方法.  </li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;采用继承Thread类的方式创建多线程的优缺点:  </p>
<ul>
<li>劣势是,因为线程类已经继承了Thread类,所以不能再继承其他父类.  </li>
<li>优势是,编写简单,如果需要访问当前线程,则无须使用Thread.currentThread()方法,直接使用this即可获得当前线程.  </li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;鉴于上面分析,因此一般推荐采用实现Runnable接口,Callable接口的方式来创建多线程. </p>
<h3 id="10-简述获取Class对象的方法"><a href="#10-简述获取Class对象的方法" class="headerlink" title="10.简述获取Class对象的方法?"></a>10.简述获取Class对象的方法?</h3><ul>
<li>使用Class类的forName(String clazzName)静态方法.该方法需要传入字符串参数,该字符串参数的值是某个类的全限定类名(必须添加完整包名).  </li>
<li>调用某个类的class属性来获得该类对应的Class对象,例如,Person.class将会返回Person类对应的Class对象.  </li>
<li>调用某个对象的getClass()方法,该方法是java.lang.Object类中的一个方法,所以所有的java对象都可以调用该方法,该方法将会返回该对象所属类对应的Class对象.  </li>
</ul>
<h3 id="11-简述通过反射生成对象的方式"><a href="#11-简述通过反射生成对象的方式" class="headerlink" title="11.简述通过反射生成对象的方式?"></a>11.简述通过反射生成对象的方式?</h3><ul>
<li>使用Class对象的newInstance()方式来创建Class对象对应类的实例,这种方式要求该Class对象的对应类有默认构造器,而执行newInstance()方法时实际上是利用构造器来创建该类的实例.  </li>
<li>先使用Class对象获取指定的Constructor对象,再调用Constructor对象的newInstance()方法来创建该Class对象对应类的实例,通过这种方式可以选择使用指定的构造器来创建实例.  </li>
</ul>
<h3 id="12-现有三个类-Root-Mid和Leaf-这三个类都提供了静态初始化块和普通初始化块-构造函数-简述每个方法的执行顺序"><a href="#12-现有三个类-Root-Mid和Leaf-这三个类都提供了静态初始化块和普通初始化块-构造函数-简述每个方法的执行顺序" class="headerlink" title="12.现有三个类:Root,Mid和Leaf,这三个类都提供了静态初始化块和普通初始化块,构造函数,简述每个方法的执行顺序?"></a>12.现有三个类:Root,Mid和Leaf,这三个类都提供了静态初始化块和普通初始化块,构造函数,简述每个方法的执行顺序?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;先执行父类的静态初始化块,依次再执行子类的初始化块,然后执行父类的普通初始化块,父类的构造器,依次执行子类的普通初始化块,子类的构造器.  </p>
<h3 id="13-简述Error和Exception的区别和关系"><a href="#13-简述Error和Exception的区别和关系" class="headerlink" title="13.简述Error和Exception的区别和关系."></a>13.简述Error和Exception的区别和关系.</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Error(错误)一般指与虚拟机相关的问题,表示系统级的错误和程序不必处理的异常,是java运行环境中的内部错误或者硬件问题,比如:内存资源不足,系统崩溃,虚拟机错误,动态链接失败等,对于这种错误,程序基本无能为力,除了退出运行外别无选择,它是由java虚拟机抛出的.<br>&nbsp;&nbsp;&nbsp;&nbsp;Exception(违例)表示需要捕捉或者需要程序进行处理的异常,它处理的是因为程序设计的瑕疵而引起的问题或者在外的输入等引起的一般性问题,是程序必须处理的.<br>&nbsp;&nbsp;&nbsp;&nbsp;Exception又分为运行时异常,受检查异常.<br>&nbsp;&nbsp;&nbsp;&nbsp;运行时异常,表示无法让程序恢复的异常,导致的原因通常是因为执行了错误的操作,建议终止程序,因此,编译器不检查这些异常.<br>&nbsp;&nbsp;&nbsp;&nbsp;受检查异常,表示程序可以处理的异常,也即表示程序可以修复(由程序自己接受异常并且做出处理),所以称之为受检查异常.  </p>
<h3 id="14-checked异常和runtime异常的区别"><a href="#14-checked异常和runtime异常的区别" class="headerlink" title="14.checked异常和runtime异常的区别."></a>14.checked异常和runtime异常的区别.</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Checked异常体现了java的设计哲学没有完善错误的代码根本不会被执行.<br>&nbsp;&nbsp;&nbsp;&nbsp;对Checked异常的处理方式有如下两种.<br>&nbsp;&nbsp;&nbsp;&nbsp;1).当前方法明确知道如何处理该异常,程序应该使用try…catch块类捕获该异常,然后在对应的catch块中修复该异常.<br>&nbsp;&nbsp;&nbsp;&nbsp;2).当前方法不知道如何处理这种异常,应该在定义该方法时声明抛出该异常.<br>&nbsp;&nbsp;&nbsp;&nbsp;Runtime异常则不知道如何处理这种异常,应该在定义该方法时声明抛出异常.  </p>
<h3 id="15-finally中的代码一定会执行吗"><a href="#15-finally中的代码一定会执行吗" class="headerlink" title="15.finally中的代码一定会执行吗?"></a>15.finally中的代码一定会执行吗?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行.  </p>
<h3 id="16-throw和throws的区别"><a href="#16-throw和throws的区别" class="headerlink" title="16.throw和throws的区别?"></a>16.throw和throws的区别?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;1).throw(针对对象的做法):<br>抛出一个异常,可以是系统定义的,也可以是自定义的.自行抛出异常常使用throw语句来完成.<br>&nbsp;&nbsp;&nbsp;&nbsp;throw语句可以单独使用,throw抛出的不是异常类,而是一个异常实例,而且每次只能抛出一个异常实例.<br>&nbsp;&nbsp;&nbsp;&nbsp;2).throws(针对一个方法抛出的异常):<br>&nbsp;&nbsp;&nbsp;&nbsp;抛出一个异常,可以是系统定义的,也可以是自定义的.<br>&nbsp;&nbsp;&nbsp;&nbsp;throws声明抛出只能在方法签名中使用,throws可以声明抛出多个异常类,多个异常类以逗号隔开.  </p>
<h3 id="17-列举5个常见的Runtime异常类"><a href="#17-列举5个常见的Runtime异常类" class="headerlink" title="17.列举5个常见的Runtime异常类."></a>17.列举5个常见的Runtime异常类.</h3><p>1).ArithmeticException:算术异常<br>2).NullPointerException:空指针异常<br>3).ArrayIndexOutOfBoundsException:数组索引越界<br>4).StringIndexOutOfBoundsExcption:String操作中索引越界<br>5).NumberFormatException:数字格式化异常<br>6).ClassCastException:类型强制转换异常  </p>
<h3 id="18-说说HashMap和HashTable的区别"><a href="#18-说说HashMap和HashTable的区别" class="headerlink" title="18.说说HashMap和HashTable的区别"></a>18.说说HashMap和HashTable的区别</h3><p>1). 执行效率不同:<br>&nbsp;&nbsp;&nbsp;&nbsp;HashMap没有采用synchronized修饰,所以线程是不安全的.<br>&nbsp;&nbsp;&nbsp;&nbsp;HashTable采用synchronized来保证线程安全,在线程竞争激烈的情况下,效率非常低.<br>2).继承类不同:<br>&nbsp;&nbsp;&nbsp;&nbsp;HashMap继承AbstractMap<br>HashTable继承Dictionary<br>3).put方法对key和value的要求不同<br>&nbsp;&nbsp;&nbsp;&nbsp;HashMap允许Entry的key或value为null<br>&nbsp;&nbsp;&nbsp;&nbsp;HashTable不允许Entry的key或value为null,否则出现NullPointerException<br>4).有无contains方法<br>&nbsp;&nbsp;&nbsp;&nbsp;HashMap没有contains方法<br>&nbsp;&nbsp;&nbsp;&nbsp;HashTable有contains方法  </p>
<h3 id="19-TreeMap和TreeSet在排序时如何比较元素-Collections工具类中的sort-方法如何比较元素"><a href="#19-TreeMap和TreeSet在排序时如何比较元素-Collections工具类中的sort-方法如何比较元素" class="headerlink" title="19.TreeMap和TreeSet在排序时如何比较元素?Collections工具类中的sort()方法如何比较元素?"></a>19.TreeMap和TreeSet在排序时如何比较元素?Collections工具类中的sort()方法如何比较元素?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;TreeSet要求存放的对象所属的类必须实现Comparable接口,该接口提供了比较元素的compareTo()方法,当插入元素时会回调该方法比较元素的大小,TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序.Collections工具类的sort方法有两种重载的形式,第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较;第二种不强制性的要求容器中的元素必须可比较,但是要求传入第二个参数,参数是Comparator接口的子类型(需要重写compare方法实现元素的比较),相当于一个临时定义的排序规则,其实就是通过注入比较元素大小的算法,也是对回调模式的应用(java中对函数式编程的支持).  </p>
<h3 id="20-方法和对象的wait-方法都可以让线程暂停执行-它们有什么区别"><a href="#20-方法和对象的wait-方法都可以让线程暂停执行-它们有什么区别" class="headerlink" title="20.()方法和对象的wait()方法都可以让线程暂停执行,它们有什么区别?"></a>20.()方法和对象的wait()方法都可以让线程暂停执行,它们有什么区别?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;sleep()方法是线程的静态方法,调用此方法会让当前线程暂停执行指定的时间,将执行机会(CPU)让给其他线程,但是对象的锁依然保持,因此休眠时间结束后会自动恢复(线程回到就绪状态),wait()方法是Object类的方法,调用对象的wait()方法导致当前线程放弃对象的锁(线程暂停执行),进入对象等待池,只有调用对象的notify()方法(或notifyAll()方法)时才能唤醒等待池中的线程进入等锁池,如果线程重新获得对象的锁就可以进入就绪状态.  </p>
<h3 id="21-当一个线程进入一个对象的synchronized方法A之后-其他线程是否可进入此对象的synchronized方法B"><a href="#21-当一个线程进入一个对象的synchronized方法A之后-其他线程是否可进入此对象的synchronized方法B" class="headerlink" title="21.当一个线程进入一个对象的synchronized方法A之后,其他线程是否可进入此对象的synchronized方法B?"></a>21.当一个线程进入一个对象的synchronized方法A之后,其他线程是否可进入此对象的synchronized方法B?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;不能,其他线程只能访问该线程非同步方法,同步方法则不能进入,因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁,如果已经进入A方法说明对象锁已经被取走,那么试图进入B方法的线程就只能在等待锁中等待对象的锁.  </p>
<h3 id="22-请说出与线程同步以及线程调度相关的方法"><a href="#22-请说出与线程同步以及线程调度相关的方法" class="headerlink" title="22.请说出与线程同步以及线程调度相关的方法?"></a>22.请说出与线程同步以及线程调度相关的方法?</h3><ul>
<li>wait():使一个线程处于等待(阻塞)状态,并且释放所持有的对象的锁;  </li>
<li>sleep():使一个正在运行的线程处于睡眠状态,是一个静态方法,调用此方法要处理InterruptedException异常.  </li>
<li>notify():唤醒一个处于等待状态的线程,当然在调用此方法的时候,并不能确切的唤醒某一个等待状态的线程,而是由JVM确定唤醒哪个线程,而且与优先级无关.  </li>
<li>nitifyAll():唤醒所有处于等待状态的线程,该方法 并不是将对象的锁给所有线程,而是让它们竞争,只有获得了锁的线程才能进入就绪状态.  </li>
</ul>
<h3 id="23-举例说明同步和异步"><a href="#23-举例说明同步和异步" class="headerlink" title="23.举例说明同步和异步."></a>23.举例说明同步和异步.</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;如果系统中存在临界资源(资源数量少于竞争资源的线程数量的资源),例如正在写的数据以后可能被另一个线程读到,或者正在读的数据可能已经被另一个线程写过了,那么这些数据就必须进行同步存取(数据库操作中的排他锁就是最好的例子),当应用程序在对象上调用了一个需要花费很长时间来执行的方法,并且不希望让程序等待方法的返回时,就应该使用异步编程,在很多情况下采用异步途径往往更有效率,事实上,所谓的同步就是指阻塞式操作,而异步就是非阻塞式操作.  </p>
<h3 id="24-方法还是start-方法"><a href="#24-方法还是start-方法" class="headerlink" title="24.()方法还是start()方法?"></a>24.()方法还是start()方法?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;启动一个线程是调用start()方法,使线程锁代表的虚拟机处于可运行状态,这意味着它可以由JVM调度并执行,这并不意味着线程就会立即执行,run()方法是线程启动后要进行回调的方法.  </p>
<h3 id="25-什么是线程池"><a href="#25-什么是线程池" class="headerlink" title="25.什么是线程池?"></a>25.什么是线程池?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;线程池顾名思义就是事先创建若干可执行的线程放入一个池(容器)中,需要的时候从池中获取线程不用自行创建,使用完毕不需要销毁线程而是放回池中,从而减少创建和销毁线程对象的开销.  </p>
<h3 id="26-简述synchronized和java-util-concurrent-locksLock的异同"><a href="#26-简述synchronized和java-util-concurrent-locksLock的异同" class="headerlink" title="26.简述synchronized和java.util.concurrent.locksLock的异同."></a>26.简述synchronized和java.util.concurrent.locksLock的异同.</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Lock是java 5以后引入的API,和关键字synchronized相比主要相同点:Lock能完成synchronized锁实现的所有功能;主要不同点:Lock有比synchronized更精确的线程语义和更好的性能,而且不强制性的要求一定要获得锁,synchronized会自动释放锁,而Lock一定要求程序员手工释放,并且最好zaifinally块中释放(这是释放外部资源的最好的地方).  </p>
<h3 id="27-java中有集中类型的流"><a href="#27-java中有集中类型的流" class="headerlink" title="27.java中有集中类型的流?"></a>27.java中有集中类型的流?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;字节流和字符流,字节流继承于InputStream,OutputStream,字节流继承于Reader,Writer.在java.io包中还有许多其他的流,主要是为提高性能和使用方便,关羽java的I/O需要注意两点:一是两种对称性(输入和输出的对程序,字节和字符的对程性);二是两种设计模式(适配器和装饰模式).另外java中的流不同于C#的是它只有一个维度一个方向.   </p>
<h3 id="28-Statement和PreparedStatement有什么区别-哪个性能更好"><a href="#28-Statement和PreparedStatement有什么区别-哪个性能更好" class="headerlink" title="28.Statement和PreparedStatement有什么区别?哪个性能更好?"></a>28.Statement和PreparedStatement有什么区别?哪个性能更好?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;与Statement相比,PreparedStatement接口代表预编译的语句,它主要的优势在于可以减少SQL的编译错误并增加SQL的安全性(减少SQL注射攻击的可能性);PreparedStatement中的SQL语句是带参数的,避免了用字符串连接拼接SQL语句的麻烦和不安全;当批量处理SQL或频繁执行相同的查询时,PreparedStatement有明显的性能上的优势,由于数据库可以将编译优化后的SQL语句缓存起来,下次执行相同接口的语句时就会很快(不用再次编译和生成执行计划).   </p>
<h3 id="29-什么是DAO模式"><a href="#29-什么是DAO模式" class="headerlink" title="29.什么是DAO模式?"></a>29.什么是DAO模式?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;DAO(Data Access Object)顾名思义就是一个为数据库或其他持久机制提供了抽象接口的对象,在不暴露底层持久化方案实现细节的前提下提供可各种数据访问操作.DAO模式实际上包含了两个模式,一是Data Accessor(数据访问器),二是Data Object(数据对象),前者要解决如何访问数据的问题,而后者要解决的是如何用对象封装数据.  </p>
<h3 id="30-事务的ACID是指什么"><a href="#30-事务的ACID是指什么" class="headerlink" title="30.事务的ACID是指什么?"></a>30.事务的ACID是指什么?</h3><ul>
<li>原子性(Atomic):事务中各项操作,要么全做要么全不做,任何意向操作的失败都会导致整个事务的失败;</li>
<li>一致性(Consistent):事务结束后系统状态是一致的;</li>
<li>隔离性(Isolated):并发执行的事务彼此无法看到对方的中间状态;</li>
<li>持久性(Durable):事务完成后所做的改动都会被持久化,即使发生灾难性的失败,通过日志和同步备份可以在故障发生后重建数据.  </li>
</ul>
<h3 id="31-简述equals-和”-”"><a href="#31-简述equals-和”-”" class="headerlink" title="31.简述equals()和”==”?"></a>31.简述equals()和”==”?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;java程序中测试两个变量是否相等有两种方式:一种是利用==运算符,另一种是利用equlas()方法,当使用==来判断两个变量是否相等时,如果两个变量是基本类型变量,且都是基本数值类型(不一定要求数据类型严格相同),则只要两个变量的值相等,就将返回true.<br>&nbsp;&nbsp;&nbsp;&nbsp;但对于两个引用类型变量,只有它们指向同一个对象时,==判断才会返回true, ==不可用于比较类型上没有父子关系的两个对象.<br>&nbsp;&nbsp;&nbsp;&nbsp;String已经重写了Object的()方法,String的equals()方法判断两个个字符串相等的标准是:只要两个字符串所包含的字符序列相同,通过equals()比较将返回true,否则将返回false.<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>注:</strong>对初学者来说,String还有一个非常容易迷惑的地方:”hello”直接量和new String(“hello”)有什么区别呢?当java程序直接使用形如”hello”的字符串直接量(包括可以在编译时就计算出来的字符串值)时,JVM将会使用常量池来管理这些字符串;当使用new String(“hello”)时,JVM会先使用常内存中,换句话说,new String(“hello”)一共产生了两个字符串对象.<br>通常而言,正确的重写equals()方法应该满足下列条件:<br>&nbsp;&nbsp;&nbsp;&nbsp;1.自反性:对任意x,x.equals(x)一定返回true.<br>&nbsp;&nbsp;&nbsp;&nbsp;2.对称性:对任意的x和y,如果y.equals(x)返回true,则x.equals(y)也返回true.<br>&nbsp;&nbsp;&nbsp;&nbsp;3.传递性:对任意x,y,z,如果x.equals(y)返回true,y.equals(z)返回true,则x.equals(z)一定返回true.<br>&nbsp;&nbsp;&nbsp;&nbsp;4.一致性:对任意的x和y,如果对象中用于等价比较的信息没有改变,那么无论调用x.equals(y)多少次,返回的结果要么一致是true,要么一直是false.<br>&nbsp;&nbsp;&nbsp;&nbsp;5.d对任何不是null的x,x.equals(null)一定返回false.  </p>
<h3 id="32-简述java程序初始化的执行顺序"><a href="#32-简述java程序初始化的执行顺序" class="headerlink" title="32.简述java程序初始化的执行顺序?"></a>32.简述java程序初始化的执行顺序?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;执行顺序:父类静态变量-&gt;父类静态代码块-&gt;子列静态变量-&gt;子列静态代码块-&gt;父类非静态变量-&gt;父类非静态代码块-&gt;父类构造函数-&gt;子类非静态变量-&gt;子类非静态代码块-&gt;子类构造函数  </p>
<h3 id="33-普通方法是否可以与构造函数有相同的方法名"><a href="#33-普通方法是否可以与构造函数有相同的方法名" class="headerlink" title="33.普通方法是否可以与构造函数有相同的方法名?"></a>33.普通方法是否可以与构造函数有相同的方法名?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;可以.  </p>
<h3 id="34-java中clone-方法的步骤"><a href="#34-java中clone-方法的步骤" class="headerlink" title="34.java中clone()方法的步骤?"></a>34.java中clone()方法的步骤?</h3><p>1.实现clone的类首先需要继承Cloneable接口,Cloneable接口实质上是一个标识接口,没有任何接口方法.<br>2.在类中重写Object类中的clone()方法.<br>3.在clone方法中调用super.clone().无论clone类的继承接口是什么,super.clone()都会直接或间接调用java.lang.Object类的clone()方法.<br>4.把浅复制的引用指向原型对象新的克隆体.<br><strong>注:</strong>1.当类中只有一些基本的数据类型时,采用上述方法就可以,但是当类中包含了一些对象时,就需要用到深复制了,实现方式是在<br>对对象调用clone()方法完成复制后,接着对对象中的非基本类型的属性也调用clone()方法完成深复制.<br>2.clone()方法的保护机制在Object中clone()是被声明为protected的.</p>
<h3 id="35-浅复制和深复制有什么区别"><a href="#35-浅复制和深复制有什么区别" class="headerlink" title="35.浅复制和深复制有什么区别?"></a>35.浅复制和深复制有什么区别?</h3><p><strong>浅复制(Shallow Clone):</strong>被复制对象的所有变量都含有与原来对象相同的值,而所有对其他对象的引用仍然指向原来的对象,换言之,浅复制仅仅复制所考虑的对象,而不复制它所引用的对象.<br><strong>深复制(Deep Clone):</strong>被复制对象的所有变量都含有与原来对象相同的值,除去那些引用其他对象的变量,而不再是原有的那些被引用的对象,换言之,深复制把复制的对象所引用的对象都复制了一遍.  </p>
<h3 id="36-java创建对象的方式有几种"><a href="#36-java创建对象的方式有几种" class="headerlink" title="36.java创建对象的方式有几种?"></a>36.java创建对象的方式有几种?</h3><p>1.通过new实例化一个对象.<br>2.通过反射机制创建对象.<br>3.通过clone()方法创建一个对象.<br>4.通过反序列化的方式创建对象.  </p>
<h3 id="37-回调函数"><a href="#37-回调函数" class="headerlink" title="37.回调函数?"></a>37.回调函数?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;回调函数就是指函数在某处注册,而它将在稍后某个需要的时候被调用,在Windows系统中,开发人员想让系统动态链接库(Dynamic Link Library,DDL)调用自己编写的一个方法,于是利用DLL当中回调函数的接口来编写程序,通过传递一个函数的指针来调用,这个过程就称为回调.<br><strong>注:</strong>在java语言中没有指针的概念,那么如何才能在java语言中实现类似于函数指针的功能?可以利用接口与类来实现相同的效果,具体而言,应先定义一个接口,然后在接口中声明要调用的方法,接着实现这个接口,最后把这个实现类的一个对象作为参数传递给调用程序,调用程序通过这个参数来调用指定的函数,从而实现回调函数的功能.  </p>
<h3 id="38-简述四个内部类"><a href="#38-简述四个内部类" class="headerlink" title="38.简述四个内部类."></a>38.简述四个内部类.</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>静态内部类:</strong>是指被声明为static的内部类,它可以不依赖于外部类实例而被实例化,而通常的内部类需要在外部类实例化后才能实例化,静态内部类不能与外部类有相同的名字,不能访问外部类的普通成员变量,只能访问外部类中的静态成员和静态方法(包括私有类型).<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>成员内部类:</strong> 可以自由的引用外部类的属性和方法,无论这些属性和方法是静态的还是非静态的,但是它与一个实例绑定在了一起,不可以定义静态的属性和方法,只有在外部类被实例化后,这个内部类才能被实例化.<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>局部内部类:</strong>指的是定义在一个代码块中的类,它的作用范围为其所在的代码块,是内部类中最少使用到的一种类型,局部内部类像局部变量一样,不能被public,protected,private以及static修饰,只能访问方法中定义为final类型的局部变量.<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>匿名内部类:</strong>是一种没有类名的内部类,不使用关键字class,extends,implements,没有构造函数,它必须继承其他类或实现其他接口,匿名内部类的好处是代码更加简洁,紧凑,但带来的问题是易读性下降,它一般应用于GUI(图形用户界面)编程中实现事件处理.在使用匿名内部时,需要牢记以下几个原则:<br>1.匿名内部类不能有构造函数.<br>2.匿名内部类不能定义静态成员,方法和类.<br>3.匿名内部类不能是public,protected,private,static.<br>4.只能创建匿名内部类的一个实例.<br>5.一个匿名内部类一定是在new的后面,这个匿名内部类必须继承一个父类或实现一个接口.<br>6.因为匿名内部类为局部内部类,所以局部内部类的所有限制都对其生效.  </p>
<h3 id="39-简述什么是实例变量-什么是局部变量-什么是类变量-什么是final变量"><a href="#39-简述什么是实例变量-什么是局部变量-什么是类变量-什么是final变量" class="headerlink" title="39.简述什么是实例变量,什么是局部变量,什么是类变量,什么是final变量?"></a>39.简述什么是实例变量,什么是局部变量,什么是类变量,什么是final变量?</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;实例变量:变量归对象所有(只有在实例化对象后猜可以).每当实例化一个对象时,会创建一个副本并初始化,如果没有显示初始化,那么会初始化一在个默认值.各个对象中的实例变量互不影响.<br>&nbsp;&nbsp;&nbsp;&nbsp;局部变量:方法中定义的变量,在使用钱必须初始化.<br>&nbsp;&nbsp;&nbsp;&nbsp;类变量:用static修饰的属性,变量归类所有,只要类被加载,这个变量就可以被使用(类名.变量名).所以实例化的对象共享类变量.  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/Java-EE-开发模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/Java-EE-开发模式/" itemprop="url">Java EE开发模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-22T13:19:55+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p></p><h3 style="text-align:center">Java EE经典三层架构</h3><br>&nbsp;&nbsp;&nbsp;&nbsp;Java EE经典的三层架构是将整个Java EE的开发过程分为Web Service Dao三层,符合MVC架构.<p></p>
<h2 id="MVC简述"><a href="#MVC简述" class="headerlink" title="MVC简述"></a>MVC简述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;式将应用程序划分为三种组件,模型-视图-控制器.<br>1.模型(Model)用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法.<br>2.视图(View)能够实现数据有目的的显示.<br>3.控制器(Controller)起到不同层面间的组织需哦用,用于控制应用程序的流程,它处理书剑并做出响应.</p>
<h3 id="分层的优势"><a href="#分层的优势" class="headerlink" title="分层的优势"></a>分层的优势</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>1.开发人员可以只关注整个结构中的其中一层;<br>2.可以很容易的用新的实现来替换原有层次的实现;<br>3.可以降低层与层之间的依赖;<br>4.有利于标准化;<br>5.利于各层逻辑的复用.<br>概括来说,分层式设计可以送达如下目的:分散关注,松散耦合,逻辑复用,标准定义.</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>1.降低了系统的性能.这是不言而喻的,如果不采用分层式结构,很多业务可以直接造访数据库,以此获取相应的数据,如今却必须通过中间层来完成.<br>2.有时会导致级联的修改.这种修改尤其体现在自上而下的方向,如果在表示层中需要增加一个功能,为保证其设计符合分层结构,可能需要在相应的业务逻辑层和数据访问层中都增加相应的代码.</p>
<h4 id="Java-EE模式历程"><a href="#Java-EE模式历程" class="headerlink" title="Java EE模式历程"></a>Java EE模式历程</h4><p><img src="http://res.cloudinary.com/fireworks/image/upload/v1512891835/JavaEE%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F_ylwwga.png" width="80%" height="10%"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/first-blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fireworks">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ghost">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/first-blog/" itemprop="url">我的博客</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-22T13:19:55+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p></p><h3 style="text-align:center">为什么会有一个属于我自己的博客呢?</h3><br>&nbsp;&nbsp;&nbsp;&nbsp;其实是由于自己的好奇心,感觉拥有自己的一个博客是非常自豪的,可以在上面发表自己的心得,记录自己的足迹.<br>&nbsp;&nbsp;&nbsp;&nbsp;第一次接触博客是在我上大一的时候,刚接触,当时的自己朦朦胧胧,就是觉得博客遥不可及,只是单纯地仰慕别人罢了,当我大三的时候,又看到别人的博客,压在心中的小火苗燃烧起来了,而自己当时在自学web前端开发,一边学习新的知识,一边和别人一起做项目,所以建一个自己博客也别搁置了.<br>&nbsp;&nbsp;&nbsp;&nbsp;现在的我已经大四了,而因学校安排,目前我在学大数据,每周会有一天自习,一天休息,闲下来的我,又各种乱想,拥有自己的一个博客的欲望越来越强,心里给自己暗示,这次的我一定不要错过了,一定要建一个属于自己的博客.<br>&nbsp;&nbsp;&nbsp;&nbsp;我就向周围同学,朋友咨询,在我的github上建了一个属于自己的博客,建好后的我心情大好,我终于有属于自己的博客了,好开心.<br>&nbsp;&nbsp;&nbsp;&nbsp;接下来的几天,我各种百度,怎么在我的博客上发表我的文章,学会后迫不及待的就尝试着发表此文章.<br>&nbsp;&nbsp;&nbsp;&nbsp;在今后的学习旅程中,我会记录我的学习心得,供大家和我一起学习.<br>&nbsp;&nbsp;&nbsp;&nbsp;活到老,学到老!<br><img src="http://res.cloudinary.com/fireworks/image/upload/v1512874125/first_blog_pzicl9.png"><p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">fireworks</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fireworks</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
